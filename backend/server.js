const express = require('express');
const app = express();
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const { default: mongoose } = require('mongoose');
const signUp = require('./backendControllers/userSignUpController');//gets the signup function
const login  = require('./backendControllers/userLoginController');//gets the login function
const searchAllUsers  = require('./backendControllers/searchAllUsersController');//gets the searchAllUsers function
const messagesModel = require('./models/messagesModel')//requiring the message model
const fetchOldMessagesWithThisUser = require('./backendControllers/fetchOldMessagesController');
const { statSync } = require('fs');
const getMyProfile = require('./backendControllers/getMyProfileController');
const uploadProfilePhoto = require('./backendControllers/uploadProfilePhotoController');
const saveToChatList = require('./backendControllers/saveToChatListController');//save user's chatlists to db
const getMyChatList = require('./backendControllers/getMyChatListController');
const changePassword = require('./backendControllers/changePasswordController');
const chatListModel = require('./models/chatListModel');
const notificationModel = require('./models/notificationModel');
const removeThisUserNotification = require('./backendControllers/removeThisUserNotificationController');
const getMyNotifications = require('./backendControllers/getMyNotificationsController');
const { findById } = require('./models/userModel');

//This is to increase the limit of file size (like image) that will be uploaded to DB
app.use(express.json({limit: '10mb'}))

//this must be added so that your post request can work
app.use(express.json())

//This is for the socket io server
app.use(cors());

//finalising createing the socket server
const server = http.createServer(app);

const io = new Server(server, {
  cors: {
    origin: "http://localhost:3000",
    methods: ["GET", "POST"]
  },
});


const PORT = 4000;//Here we're setting the port number for our server


//CONNECTING TO DATABASE

const dbURL = ". . . . . PUT YOUR MONGODB DATABASE API KEY HERE. . . . .";

async function connectDb(){

  try {
 
    await mongoose.connect(dbURL);

    console.log('CONNECTED TO THE DATABASE')

  } catch (error) { 

    console.error("Error connecting to the Database is: " + error)

  }

}

//password: webChatApp
connectDb();


//HANDLING DIFFERENT REQUESTS FROM CLIENT

//Handling sign up request from the client
app.post('/signUp', signUp)

////Handling login request from client
app.post('/login', login)

app.post('/searchAllUsers', searchAllUsers)

//Handling fetching messages request
app.post('/fetchOldMessagesWithThisUser', fetchOldMessagesWithThisUser)

//Handling getting users' profile
app.post('/getMyProfile', getMyProfile)

//Handling profile picture upload
app.post('/uploadProfilePhoto', uploadProfilePhoto)

//Handling saving of chatlist to db
app.post('/saveToChatList', saveToChatList)

//Handling getting a user chat list
app.post('/getMyChatList', getMyChatList)

//Handling changing of password
app.post('/changePassword', changePassword)

//Handle removing someone from my notification list
app.post('/removeThisUserNotification', removeThisUserNotification)

//Handle getting all notification for a user
app.post('/getMyNotifications', getMyNotifications)



//ARRAY TO STORE LISTS OF USERS CURRENTLY CONNECTED TO SOCKET IO SERVER

//This empty array will be filled up by those connected to the server
var connectedUsers = [  ]


//SOCKET IO IMPLEMENTATION . . . . . . . .

//Now let us work with the socket io implementation
//Remember all you'd be doing with socket io is to listen 

//The way socket io works is that you create certain events 
//and you name those events.

//Two basic things you do in socket io is that you listen to an
//event or you emit an event ("event" that is sending data to all the 
//clients connected to the server).

//Now let's start listening to some event

//The "connection" listener listens for when a user connect
//or opens the page.

io.on("connection", (socket) => {

    //we get the socket varable from the parameter in this 
    //callback function. The socket variable is an inbuilt 
    //parameter that comes with socket io. we can use it to get
    //a lot of information for example we can console log whenever
    //smeone join using the .on method with the socket key word
    //that is ===> socket.on
    console.log(`User connected: ${socket.id}`) //This console log to our server when a user connects.


   //This will listen for when a user login, and then gets their username (couple with random 
   //socket id we give them generated by socket io. and add it to our array of connected users 
   //using the push method.
    socket.on("username", (data) => {

      function addDetailsToConnectedUsersArray () {

          connectedUsers.push({username: data.username, id: socket.id});

      }

      addDetailsToConnectedUsersArray();

      console.log(connectedUsers.length + ' ' + 'users connected to our server');

      console.log('connected names are:' + JSON.stringify(connectedUsers))
 
    });

    

    //This will listen for the send message event (the data will come from the frontend),
    //then it will emit it to other client connected to it.
    socket.on("send_message", (data) => { 

      //assigning all three important info consigning the message using array of variables so we can  
      //properly save them to Database instead of doing it separately... (it's still works the same 
      //if you separate them)...


      const [message, from, to] = [data.message, data.from, data.to]
      

      //Let's find both the from and to user in the connectedUsers array and then if exist, store
      //the item int a variable.. that we'd later use to get their id to send message to.
      let storeFromPersonFindItem = connectedUsers.find(item => item.username === from);
      let storeToPersonFindItem = connectedUsers.find(item => item.username === to);

      //This checks if the to person is not stored in the connected user array or hasn't connected yet.
      if (storeToPersonFindItem == null) {

        //if 'to' hasn't connected, get the sender's socket id and emit the message only to them.
        let sendFromSocketId = storeFromPersonFindItem.id

        //before we emit the message to the sender's client alone, lets first save message to database
        const createdMessage = new messagesModel({ message: message, from: from, to: to });
        const savedMessage = createdMessage.save()

        savedMessage.then(() => {

        //After message is saved to DB, let's emitting the message to only you.
        io.to(sendFromSocketId).emit("receive_message", data)

        //Then let's add you to the other person's chatlist so they can see you on their chatlist 
        //on the frontend when they login and come online.
        async function addMeToOtherPersonChatList() {

          //let's first check if you are already present in their chatlist to avoid making a duplicate
          const letSee = await chatListModel.findOne({loggedInUser:to, personToSaveToChatList: from})

          if (letSee) {

          } else {

            const addToOtherPersonChatList = await new chatListModel({ loggedInUser: to, 

                                                                      personToSaveToChatList: from
                                                                });
            addToOtherPersonChatList.save();      

          }

        } //addMeToOtherPersonChatList() function closing


        addMeToOtherPersonChatList()
        
  

        }).catch((error) => {

          console.log("message failed to store in database error: " + error);

        })



        //let add you the the other person's notification list when you send 
        //the a message and they are not connected to the server
        async function addMeToOtherPersonNotificationList () {

          const addToOtherPersonNotificationList = new notificationModel({

                                                    username: to,

                                                    personToAddToNotificationList: from

                                                  });


         addToOtherPersonNotificationList.save()                                         



        }


        addMeToOtherPersonNotificationList();



      }//storeToPerson is not connected CLOSING DIV 



      //This checks if the to person is connected to the socket server
      if (storeToPersonFindItem) {

        //if to person is connected, get the sender and to id and them emit the message to both of them.
        let sendFromSocketId = storeFromPersonFindItem.id
        let sendToSocketId = storeToPersonFindItem.id

        //before we emit the message to both client, let first save it to database
        const createdMessage = new messagesModel({ message: message, from: from, to: to });
        const savedMessage = createdMessage.save()

        savedMessage.then(() => {

          io.to(sendFromSocketId).to(sendToSocketId).emit("receive_message", data)

        }).catch((error) => {

          console.log("message failed to store in database error: " + error)
        })
        

      }


        //Remember, accoreding to socket io doc, io.emit() will send the message to all the client
        //that are connected to this socket server. but using the io.to().emit will emit the message
        //only to the particular client which we stated. In our case it's (to's socket id) , the message 
        //will be emitted. to the (to) property which we identify as the other registerd user that we're 
        //chatting with. So here, we give it a first argument of "receive_message" then a second of data 
        //which is the message to be emitted.
        //Note: you'd have to write code that will listen to this event on the client so that 
        //it can be printed out on there.

         //loggint the message sent to the console.
          console.log(data.message);

       
    });



    //This is used to listen when the other user is typing and then emitting the ( "someone 
    //is typing" ) message to every other person connected in the socket io server
    socket.on('typing', (data) => {

      const { typingNotification, userNameTyping, userNameReceivingTyping } = data;

      let storeUserNameReceivingTypingFindItem = connectedUsers.find(item => item.username === userNameReceivingTyping);

      //This checks if the to person is not stored in the connected user array or hasn't connected yet.
       if (storeUserNameReceivingTypingFindItem == null) {

      }


       //This checks if the to person to receiving the typing notification is connected to the socket server
       if (storeUserNameReceivingTypingFindItem) {

        //if the person is connected, get the person's id and them emit the message to the receiver.
        let userNameReceivingTypingSocketId =  storeUserNameReceivingTypingFindItem.id

        socket.broadcast.to(userNameReceivingTypingSocketId).emit("isTyping", data);

        console.log(data)
       
      }

      
    });


    //This listens for when the other user is not typing and then emitting an empty string
    socket.on("notTyping", (data) => {

      socket.broadcast.emit("isNotTyping", data);

    })


    //This listens for who to add to notification list
    socket.on("addToNotification", (data) => {

      const user = data.userName;
      const p = data.personToAddToNotificationList;
     
      //saving someone to your notification database when they send you a
      //message and it's not them you're currently chatting with
      const addToNotification = new notificationModel({username: user, personToAddToNotificationList: p})

      addToNotification.save((err, data) => {
        
        if (err) {

          console.log('notification err is' + err)

        }

        if (data) {

        //if saving to database successful, lets find your socket id and send you
        //the notification data so you can see it.
        let storeUserFindItem = connectedUsers.find(item => item.username === user);

          if (storeUserFindItem) {

            let userSocketId =  storeUserFindItem.id
//console.log('the data is' + data + loggedInUserSocketId)
            //Emitting the data to you
            io.to(userSocketId).emit("myNotification", data);

          }
          
          
        }

      });



    });


    //listens for when user is access the application on small screen
    socket.on("small-screen-connection", (data) => {

      console.log(data.smallScreenAlert)

    });


    //This listens to when the other user disconnects from the server and 
    //and then prints whoever disconnected
    
    socket.on("disconnect", (data) => {

      console.log(`${socket.id} just disconnected`);
      //Now we say anytime a user disconnects, let's remove the user from
      //the array that stores the list of connected user
      let newListOfConnectedUser = connectedUsers.filter(item => item.id !== socket.id);

      connectedUsers = newListOfConnectedUser

      console.log('connected names left:' + JSON.stringify(connectedUsers))

    });
    
    
});



server.listen(PORT, () => {
  console.log(`server is running on port ${PORT}`);
})


/*
  IMPORTANT NOTE:
      remember for every event you listen for, there must be a call back function
      following it as the next argument.

*/
