{"ast":null,"code":"/**\n * Browser Image Compression\n * v2.0.2\n * by Donald <donaldcwl@gmail.com>\n * https://github.com/Donaldcwl/browser-image-compression\n */\nfunction _mergeNamespaces(e, t) {\n  return t.forEach(function (t) {\n    t && \"string\" != typeof t && !Array.isArray(t) && Object.keys(t).forEach(function (r) {\n      if (\"default\" !== r && !(r in e)) {\n        var i = Object.getOwnPropertyDescriptor(t, r);\n        Object.defineProperty(e, r, i.get ? i : {\n          enumerable: !0,\n          get: function () {\n            return t[r];\n          }\n        });\n      }\n    });\n  }), Object.freeze(e);\n}\n\nfunction copyExifWithoutOrientation(e, t) {\n  return new Promise(function (r, i) {\n    let o;\n    return getApp1Segment(e).then(function (e) {\n      try {\n        return o = e, r(new Blob([t.slice(0, 2), o, t.slice(2)], {\n          type: \"image/jpeg\"\n        }));\n      } catch (e) {\n        return i(e);\n      }\n    }, i);\n  });\n}\n\nconst getApp1Segment = e => new Promise((t, r) => {\n  const i = new FileReader();\n  i.addEventListener(\"load\", _ref => {\n    let {\n      target: {\n        result: e\n      }\n    } = _ref;\n    const i = new DataView(e);\n    let o = 0;\n    if (65496 !== i.getUint16(o)) return r(\"not a valid JPEG\");\n\n    for (o += 2;;) {\n      const a = i.getUint16(o);\n      if (65498 === a) break;\n      const s = i.getUint16(o + 2);\n\n      if (65505 === a && 1165519206 === i.getUint32(o + 4)) {\n        const a = o + 10;\n        let f;\n\n        switch (i.getUint16(a)) {\n          case 18761:\n            f = !0;\n            break;\n\n          case 19789:\n            f = !1;\n            break;\n\n          default:\n            return r(\"TIFF header contains invalid endian\");\n        }\n\n        if (42 !== i.getUint16(a + 2, f)) return r(\"TIFF header contains invalid version\");\n        const l = i.getUint32(a + 4, f),\n              c = a + l + 2 + 12 * i.getUint16(a + l, f);\n\n        for (let e = a + l + 2; e < c; e += 12) {\n          if (274 == i.getUint16(e, f)) {\n            if (3 !== i.getUint16(e + 2, f)) return r(\"Orientation data type is invalid\");\n            if (1 !== i.getUint32(e + 4, f)) return r(\"Orientation data count is invalid\");\n            i.setUint16(e + 8, 1, f);\n            break;\n          }\n        }\n\n        return t(e.slice(o, o + 2 + s));\n      }\n\n      o += 2 + s;\n    }\n\n    return t(new Blob());\n  }), i.readAsArrayBuffer(e);\n});\n\nvar e = {},\n    t = {\n  get exports() {\n    return e;\n  },\n\n  set exports(t) {\n    e = t;\n  }\n\n};\n!function (e) {\n  var r,\n      i,\n      UZIP = {};\n  t.exports = UZIP, UZIP.parse = function (e, t) {\n    for (var r = UZIP.bin.readUshort, i = UZIP.bin.readUint, o = 0, a = {}, s = new Uint8Array(e), f = s.length - 4; 101010256 != i(s, f);) f--;\n\n    o = f;\n    o += 4;\n    var l = r(s, o += 4);\n    r(s, o += 2);\n    var c = i(s, o += 2),\n        u = i(s, o += 4);\n    o += 4, o = u;\n\n    for (var h = 0; h < l; h++) {\n      i(s, o), o += 4, o += 4, o += 4, i(s, o += 4);\n      c = i(s, o += 4);\n      var d = i(s, o += 4),\n          A = r(s, o += 4),\n          g = r(s, o + 2),\n          p = r(s, o + 4);\n      o += 6;\n      var m = i(s, o += 8);\n      o += 4, o += A + g + p, UZIP._readLocal(s, m, a, c, d, t);\n    }\n\n    return a;\n  }, UZIP._readLocal = function (e, t, r, i, o, a) {\n    var s = UZIP.bin.readUshort,\n        f = UZIP.bin.readUint;\n    f(e, t), s(e, t += 4), s(e, t += 2);\n    var l = s(e, t += 2);\n    f(e, t += 2), f(e, t += 4), t += 4;\n    var c = s(e, t += 8),\n        u = s(e, t += 2);\n    t += 2;\n    var h = UZIP.bin.readUTF8(e, t, c);\n    if (t += c, t += u, a) r[h] = {\n      size: o,\n      csize: i\n    };else {\n      var d = new Uint8Array(e.buffer, t);\n      if (0 == l) r[h] = new Uint8Array(d.buffer.slice(t, t + i));else {\n        if (8 != l) throw \"unknown compression method: \" + l;\n        var A = new Uint8Array(o);\n        UZIP.inflateRaw(d, A), r[h] = A;\n      }\n    }\n  }, UZIP.inflateRaw = function (e, t) {\n    return UZIP.F.inflate(e, t);\n  }, UZIP.inflate = function (e, t) {\n    return e[0], e[1], UZIP.inflateRaw(new Uint8Array(e.buffer, e.byteOffset + 2, e.length - 6), t);\n  }, UZIP.deflate = function (e, t) {\n    null == t && (t = {\n      level: 6\n    });\n    var r = 0,\n        i = new Uint8Array(50 + Math.floor(1.1 * e.length));\n    i[r] = 120, i[r + 1] = 156, r += 2, r = UZIP.F.deflateRaw(e, i, r, t.level);\n    var o = UZIP.adler(e, 0, e.length);\n    return i[r + 0] = o >>> 24 & 255, i[r + 1] = o >>> 16 & 255, i[r + 2] = o >>> 8 & 255, i[r + 3] = o >>> 0 & 255, new Uint8Array(i.buffer, 0, r + 4);\n  }, UZIP.deflateRaw = function (e, t) {\n    null == t && (t = {\n      level: 6\n    });\n    var r = new Uint8Array(50 + Math.floor(1.1 * e.length)),\n        i = UZIP.F.deflateRaw(e, r, i, t.level);\n    return new Uint8Array(r.buffer, 0, i);\n  }, UZIP.encode = function (e, t) {\n    null == t && (t = !1);\n    var r = 0,\n        i = UZIP.bin.writeUint,\n        o = UZIP.bin.writeUshort,\n        a = {};\n\n    for (var s in e) {\n      var f = !UZIP._noNeed(s) && !t,\n          l = e[s],\n          c = UZIP.crc.crc(l, 0, l.length);\n      a[s] = {\n        cpr: f,\n        usize: l.length,\n        crc: c,\n        file: f ? UZIP.deflateRaw(l) : l\n      };\n    }\n\n    for (var s in a) r += a[s].file.length + 30 + 46 + 2 * UZIP.bin.sizeUTF8(s);\n\n    r += 22;\n    var u = new Uint8Array(r),\n        h = 0,\n        d = [];\n\n    for (var s in a) {\n      var A = a[s];\n      d.push(h), h = UZIP._writeHeader(u, h, s, A, 0);\n    }\n\n    var g = 0,\n        p = h;\n\n    for (var s in a) {\n      A = a[s];\n      d.push(h), h = UZIP._writeHeader(u, h, s, A, 1, d[g++]);\n    }\n\n    var m = h - p;\n    return i(u, h, 101010256), h += 4, o(u, h += 4, g), o(u, h += 2, g), i(u, h += 2, m), i(u, h += 4, p), h += 4, h += 2, u.buffer;\n  }, UZIP._noNeed = function (e) {\n    var t = e.split(\".\").pop().toLowerCase();\n    return -1 != \"png,jpg,jpeg,zip\".indexOf(t);\n  }, UZIP._writeHeader = function (e, t, r, i, o, a) {\n    var s = UZIP.bin.writeUint,\n        f = UZIP.bin.writeUshort,\n        l = i.file;\n    return s(e, t, 0 == o ? 67324752 : 33639248), t += 4, 1 == o && (t += 2), f(e, t, 20), f(e, t += 2, 0), f(e, t += 2, i.cpr ? 8 : 0), s(e, t += 2, 0), s(e, t += 4, i.crc), s(e, t += 4, l.length), s(e, t += 4, i.usize), f(e, t += 4, UZIP.bin.sizeUTF8(r)), f(e, t += 2, 0), t += 2, 1 == o && (t += 2, t += 2, s(e, t += 6, a), t += 4), t += UZIP.bin.writeUTF8(e, t, r), 0 == o && (e.set(l, t), t += l.length), t;\n  }, UZIP.crc = {\n    table: function () {\n      for (var e = new Uint32Array(256), t = 0; t < 256; t++) {\n        for (var r = t, i = 0; i < 8; i++) 1 & r ? r = 3988292384 ^ r >>> 1 : r >>>= 1;\n\n        e[t] = r;\n      }\n\n      return e;\n    }(),\n    update: function (e, t, r, i) {\n      for (var o = 0; o < i; o++) e = UZIP.crc.table[255 & (e ^ t[r + o])] ^ e >>> 8;\n\n      return e;\n    },\n    crc: function (e, t, r) {\n      return 4294967295 ^ UZIP.crc.update(4294967295, e, t, r);\n    }\n  }, UZIP.adler = function (e, t, r) {\n    for (var i = 1, o = 0, a = t, s = t + r; a < s;) {\n      for (var f = Math.min(a + 5552, s); a < f;) o += i += e[a++];\n\n      i %= 65521, o %= 65521;\n    }\n\n    return o << 16 | i;\n  }, UZIP.bin = {\n    readUshort: function (e, t) {\n      return e[t] | e[t + 1] << 8;\n    },\n    writeUshort: function (e, t, r) {\n      e[t] = 255 & r, e[t + 1] = r >> 8 & 255;\n    },\n    readUint: function (e, t) {\n      return 16777216 * e[t + 3] + (e[t + 2] << 16 | e[t + 1] << 8 | e[t]);\n    },\n    writeUint: function (e, t, r) {\n      e[t] = 255 & r, e[t + 1] = r >> 8 & 255, e[t + 2] = r >> 16 & 255, e[t + 3] = r >> 24 & 255;\n    },\n    readASCII: function (e, t, r) {\n      for (var i = \"\", o = 0; o < r; o++) i += String.fromCharCode(e[t + o]);\n\n      return i;\n    },\n    writeASCII: function (e, t, r) {\n      for (var i = 0; i < r.length; i++) e[t + i] = r.charCodeAt(i);\n    },\n    pad: function (e) {\n      return e.length < 2 ? \"0\" + e : e;\n    },\n    readUTF8: function (e, t, r) {\n      for (var i, o = \"\", a = 0; a < r; a++) o += \"%\" + UZIP.bin.pad(e[t + a].toString(16));\n\n      try {\n        i = decodeURIComponent(o);\n      } catch (i) {\n        return UZIP.bin.readASCII(e, t, r);\n      }\n\n      return i;\n    },\n    writeUTF8: function (e, t, r) {\n      for (var i = r.length, o = 0, a = 0; a < i; a++) {\n        var s = r.charCodeAt(a);\n        if (0 == (4294967168 & s)) e[t + o] = s, o++;else if (0 == (4294965248 & s)) e[t + o] = 192 | s >> 6, e[t + o + 1] = 128 | s >> 0 & 63, o += 2;else if (0 == (4294901760 & s)) e[t + o] = 224 | s >> 12, e[t + o + 1] = 128 | s >> 6 & 63, e[t + o + 2] = 128 | s >> 0 & 63, o += 3;else {\n          if (0 != (4292870144 & s)) throw \"e\";\n          e[t + o] = 240 | s >> 18, e[t + o + 1] = 128 | s >> 12 & 63, e[t + o + 2] = 128 | s >> 6 & 63, e[t + o + 3] = 128 | s >> 0 & 63, o += 4;\n        }\n      }\n\n      return o;\n    },\n    sizeUTF8: function (e) {\n      for (var t = e.length, r = 0, i = 0; i < t; i++) {\n        var o = e.charCodeAt(i);\n        if (0 == (4294967168 & o)) r++;else if (0 == (4294965248 & o)) r += 2;else if (0 == (4294901760 & o)) r += 3;else {\n          if (0 != (4292870144 & o)) throw \"e\";\n          r += 4;\n        }\n      }\n\n      return r;\n    }\n  }, UZIP.F = {}, UZIP.F.deflateRaw = function (e, t, r, i) {\n    var o = [[0, 0, 0, 0, 0], [4, 4, 8, 4, 0], [4, 5, 16, 8, 0], [4, 6, 16, 16, 0], [4, 10, 16, 32, 0], [8, 16, 32, 32, 0], [8, 16, 128, 128, 0], [8, 32, 128, 256, 0], [32, 128, 258, 1024, 1], [32, 258, 258, 4096, 1]][i],\n        a = UZIP.F.U,\n        s = UZIP.F._goodIndex;\n    UZIP.F._hash;\n    var f = UZIP.F._putsE,\n        l = 0,\n        c = r << 3,\n        u = 0,\n        h = e.length;\n\n    if (0 == i) {\n      for (; l < h;) {\n        f(t, c, l + (_ = Math.min(65535, h - l)) == h ? 1 : 0), c = UZIP.F._copyExact(e, l, _, t, c + 8), l += _;\n      }\n\n      return c >>> 3;\n    }\n\n    var d = a.lits,\n        A = a.strt,\n        g = a.prev,\n        p = 0,\n        m = 0,\n        w = 0,\n        v = 0,\n        b = 0,\n        y = 0;\n\n    for (h > 2 && (A[y = UZIP.F._hash(e, 0)] = 0), l = 0; l < h; l++) {\n      if (b = y, l + 1 < h - 2) {\n        y = UZIP.F._hash(e, l + 1);\n        var E = l + 1 & 32767;\n        g[E] = A[y], A[y] = E;\n      }\n\n      if (u <= l) {\n        (p > 14e3 || m > 26697) && h - l > 100 && (u < l && (d[p] = l - u, p += 2, u = l), c = UZIP.F._writeBlock(l == h - 1 || u == h ? 1 : 0, d, p, v, e, w, l - w, t, c), p = m = v = 0, w = l);\n        var F = 0;\n        l < h - 2 && (F = UZIP.F._bestMatch(e, l, g, b, Math.min(o[2], h - l), o[3]));\n\n        var _ = F >>> 16,\n            B = 65535 & F;\n\n        if (0 != F) {\n          B = 65535 & F;\n          var U = s(_ = F >>> 16, a.of0);\n          a.lhst[257 + U]++;\n          var C = s(B, a.df0);\n          a.dhst[C]++, v += a.exb[U] + a.dxb[C], d[p] = _ << 23 | l - u, d[p + 1] = B << 16 | U << 8 | C, p += 2, u = l + _;\n        } else a.lhst[e[l]]++;\n\n        m++;\n      }\n    }\n\n    for (w == l && 0 != e.length || (u < l && (d[p] = l - u, p += 2, u = l), c = UZIP.F._writeBlock(1, d, p, v, e, w, l - w, t, c), p = 0, m = 0, p = m = v = 0, w = l); 0 != (7 & c);) c++;\n\n    return c >>> 3;\n  }, UZIP.F._bestMatch = function (e, t, r, i, o, a) {\n    var s = 32767 & t,\n        f = r[s],\n        l = s - f + 32768 & 32767;\n    if (f == s || i != UZIP.F._hash(e, t - l)) return 0;\n\n    for (var c = 0, u = 0, h = Math.min(32767, t); l <= h && 0 != --a && f != s;) {\n      if (0 == c || e[t + c] == e[t + c - l]) {\n        var d = UZIP.F._howLong(e, t, l);\n\n        if (d > c) {\n          if (u = l, (c = d) >= o) break;\n          l + 2 < d && (d = l + 2);\n\n          for (var A = 0, g = 0; g < d - 2; g++) {\n            var p = t - l + g + 32768 & 32767,\n                m = p - r[p] + 32768 & 32767;\n            m > A && (A = m, f = p);\n          }\n        }\n      }\n\n      l += (s = f) - (f = r[s]) + 32768 & 32767;\n    }\n\n    return c << 16 | u;\n  }, UZIP.F._howLong = function (e, t, r) {\n    if (e[t] != e[t - r] || e[t + 1] != e[t + 1 - r] || e[t + 2] != e[t + 2 - r]) return 0;\n    var i = t,\n        o = Math.min(e.length, t + 258);\n\n    for (t += 3; t < o && e[t] == e[t - r];) t++;\n\n    return t - i;\n  }, UZIP.F._hash = function (e, t) {\n    return (e[t] << 8 | e[t + 1]) + (e[t + 2] << 4) & 65535;\n  }, UZIP.saved = 0, UZIP.F._writeBlock = function (e, t, r, i, o, a, s, f, l) {\n    var c,\n        u,\n        h,\n        d,\n        A,\n        g,\n        p,\n        m,\n        w,\n        v = UZIP.F.U,\n        b = UZIP.F._putsF,\n        y = UZIP.F._putsE;\n    v.lhst[256]++, u = (c = UZIP.F.getTrees())[0], h = c[1], d = c[2], A = c[3], g = c[4], p = c[5], m = c[6], w = c[7];\n\n    var E = 32 + (0 == (l + 3 & 7) ? 0 : 8 - (l + 3 & 7)) + (s << 3),\n        F = i + UZIP.F.contSize(v.fltree, v.lhst) + UZIP.F.contSize(v.fdtree, v.dhst),\n        _ = i + UZIP.F.contSize(v.ltree, v.lhst) + UZIP.F.contSize(v.dtree, v.dhst);\n\n    _ += 14 + 3 * p + UZIP.F.contSize(v.itree, v.ihst) + (2 * v.ihst[16] + 3 * v.ihst[17] + 7 * v.ihst[18]);\n\n    for (var B = 0; B < 286; B++) v.lhst[B] = 0;\n\n    for (B = 0; B < 30; B++) v.dhst[B] = 0;\n\n    for (B = 0; B < 19; B++) v.ihst[B] = 0;\n\n    var U = E < F && E < _ ? 0 : F < _ ? 1 : 2;\n\n    if (b(f, l, e), b(f, l + 1, U), l += 3, 0 == U) {\n      for (; 0 != (7 & l);) l++;\n\n      l = UZIP.F._copyExact(o, a, s, f, l);\n    } else {\n      var C, I;\n\n      if (1 == U && (C = v.fltree, I = v.fdtree), 2 == U) {\n        UZIP.F.makeCodes(v.ltree, u), UZIP.F.revCodes(v.ltree, u), UZIP.F.makeCodes(v.dtree, h), UZIP.F.revCodes(v.dtree, h), UZIP.F.makeCodes(v.itree, d), UZIP.F.revCodes(v.itree, d), C = v.ltree, I = v.dtree, y(f, l, A - 257), y(f, l += 5, g - 1), y(f, l += 5, p - 4), l += 4;\n\n        for (var Q = 0; Q < p; Q++) y(f, l + 3 * Q, v.itree[1 + (v.ordr[Q] << 1)]);\n\n        l += 3 * p, l = UZIP.F._codeTiny(m, v.itree, f, l), l = UZIP.F._codeTiny(w, v.itree, f, l);\n      }\n\n      for (var M = a, x = 0; x < r; x += 2) {\n        for (var S = t[x], R = S >>> 23, T = M + (8388607 & S); M < T;) l = UZIP.F._writeLit(o[M++], C, f, l);\n\n        if (0 != R) {\n          var O = t[x + 1],\n              P = O >> 16,\n              H = O >> 8 & 255,\n              L = 255 & O;\n          y(f, l = UZIP.F._writeLit(257 + H, C, f, l), R - v.of0[H]), l += v.exb[H], b(f, l = UZIP.F._writeLit(L, I, f, l), P - v.df0[L]), l += v.dxb[L], M += R;\n        }\n      }\n\n      l = UZIP.F._writeLit(256, C, f, l);\n    }\n\n    return l;\n  }, UZIP.F._copyExact = function (e, t, r, i, o) {\n    var a = o >>> 3;\n    return i[a] = r, i[a + 1] = r >>> 8, i[a + 2] = 255 - i[a], i[a + 3] = 255 - i[a + 1], a += 4, i.set(new Uint8Array(e.buffer, t, r), a), o + (r + 4 << 3);\n  }, UZIP.F.getTrees = function () {\n    for (var e = UZIP.F.U, t = UZIP.F._hufTree(e.lhst, e.ltree, 15), r = UZIP.F._hufTree(e.dhst, e.dtree, 15), i = [], o = UZIP.F._lenCodes(e.ltree, i), a = [], s = UZIP.F._lenCodes(e.dtree, a), f = 0; f < i.length; f += 2) e.ihst[i[f]]++;\n\n    for (f = 0; f < a.length; f += 2) e.ihst[a[f]]++;\n\n    for (var l = UZIP.F._hufTree(e.ihst, e.itree, 7), c = 19; c > 4 && 0 == e.itree[1 + (e.ordr[c - 1] << 1)];) c--;\n\n    return [t, r, l, o, s, c, i, a];\n  }, UZIP.F.getSecond = function (e) {\n    for (var t = [], r = 0; r < e.length; r += 2) t.push(e[r + 1]);\n\n    return t;\n  }, UZIP.F.nonZero = function (e) {\n    for (var t = \"\", r = 0; r < e.length; r += 2) 0 != e[r + 1] && (t += (r >> 1) + \",\");\n\n    return t;\n  }, UZIP.F.contSize = function (e, t) {\n    for (var r = 0, i = 0; i < t.length; i++) r += t[i] * e[1 + (i << 1)];\n\n    return r;\n  }, UZIP.F._codeTiny = function (e, t, r, i) {\n    for (var o = 0; o < e.length; o += 2) {\n      var a = e[o],\n          s = e[o + 1];\n      i = UZIP.F._writeLit(a, t, r, i);\n      var f = 16 == a ? 2 : 17 == a ? 3 : 7;\n      a > 15 && (UZIP.F._putsE(r, i, s, f), i += f);\n    }\n\n    return i;\n  }, UZIP.F._lenCodes = function (e, t) {\n    for (var r = e.length; 2 != r && 0 == e[r - 1];) r -= 2;\n\n    for (var i = 0; i < r; i += 2) {\n      var o = e[i + 1],\n          a = i + 3 < r ? e[i + 3] : -1,\n          s = i + 5 < r ? e[i + 5] : -1,\n          f = 0 == i ? -1 : e[i - 1];\n\n      if (0 == o && a == o && s == o) {\n        for (var l = i + 5; l + 2 < r && e[l + 2] == o;) l += 2;\n\n        (c = Math.min(l + 1 - i >>> 1, 138)) < 11 ? t.push(17, c - 3) : t.push(18, c - 11), i += 2 * c - 2;\n      } else if (o == f && a == o && s == o) {\n        for (l = i + 5; l + 2 < r && e[l + 2] == o;) l += 2;\n\n        var c = Math.min(l + 1 - i >>> 1, 6);\n        t.push(16, c - 3), i += 2 * c - 2;\n      } else t.push(o, 0);\n    }\n\n    return r >>> 1;\n  }, UZIP.F._hufTree = function (e, t, r) {\n    var i = [],\n        o = e.length,\n        a = t.length,\n        s = 0;\n\n    for (s = 0; s < a; s += 2) t[s] = 0, t[s + 1] = 0;\n\n    for (s = 0; s < o; s++) 0 != e[s] && i.push({\n      lit: s,\n      f: e[s]\n    });\n\n    var f = i.length,\n        l = i.slice(0);\n    if (0 == f) return 0;\n\n    if (1 == f) {\n      var c = i[0].lit;\n      l = 0 == c ? 1 : 0;\n      return t[1 + (c << 1)] = 1, t[1 + (l << 1)] = 1, 1;\n    }\n\n    i.sort(function (e, t) {\n      return e.f - t.f;\n    });\n    var u = i[0],\n        h = i[1],\n        d = 0,\n        A = 1,\n        g = 2;\n\n    for (i[0] = {\n      lit: -1,\n      f: u.f + h.f,\n      l: u,\n      r: h,\n      d: 0\n    }; A != f - 1;) u = d != A && (g == f || i[d].f < i[g].f) ? i[d++] : i[g++], h = d != A && (g == f || i[d].f < i[g].f) ? i[d++] : i[g++], i[A++] = {\n      lit: -1,\n      f: u.f + h.f,\n      l: u,\n      r: h\n    };\n\n    var p = UZIP.F.setDepth(i[A - 1], 0);\n\n    for (p > r && (UZIP.F.restrictDepth(l, r, p), p = r), s = 0; s < f; s++) t[1 + (l[s].lit << 1)] = l[s].d;\n\n    return p;\n  }, UZIP.F.setDepth = function (e, t) {\n    return -1 != e.lit ? (e.d = t, t) : Math.max(UZIP.F.setDepth(e.l, t + 1), UZIP.F.setDepth(e.r, t + 1));\n  }, UZIP.F.restrictDepth = function (e, t, r) {\n    var i = 0,\n        o = 1 << r - t,\n        a = 0;\n\n    for (e.sort(function (e, t) {\n      return t.d == e.d ? e.f - t.f : t.d - e.d;\n    }), i = 0; i < e.length && e[i].d > t; i++) {\n      var s = e[i].d;\n      e[i].d = t, a += o - (1 << r - s);\n    }\n\n    for (a >>>= r - t; a > 0;) {\n      (s = e[i].d) < t ? (e[i].d++, a -= 1 << t - s - 1) : i++;\n    }\n\n    for (; i >= 0; i--) e[i].d == t && a < 0 && (e[i].d--, a++);\n\n    0 != a && console.log(\"debt left\");\n  }, UZIP.F._goodIndex = function (e, t) {\n    var r = 0;\n    return t[16 | r] <= e && (r |= 16), t[8 | r] <= e && (r |= 8), t[4 | r] <= e && (r |= 4), t[2 | r] <= e && (r |= 2), t[1 | r] <= e && (r |= 1), r;\n  }, UZIP.F._writeLit = function (e, t, r, i) {\n    return UZIP.F._putsF(r, i, t[e << 1]), i + t[1 + (e << 1)];\n  }, UZIP.F.inflate = function (e, t) {\n    var r = Uint8Array;\n    if (3 == e[0] && 0 == e[1]) return t || new r(0);\n    var i = UZIP.F,\n        o = i._bitsF,\n        a = i._bitsE,\n        s = i._decodeTiny,\n        f = i.makeCodes,\n        l = i.codes2map,\n        c = i._get17,\n        u = i.U,\n        h = null == t;\n    h && (t = new r(e.length >>> 2 << 3));\n\n    for (var d, A, g = 0, p = 0, m = 0, w = 0, v = 0, b = 0, y = 0, E = 0, F = 0; 0 == g;) if (g = o(e, F, 1), p = o(e, F + 1, 2), F += 3, 0 != p) {\n      if (h && (t = UZIP.F._check(t, E + (1 << 17))), 1 == p && (d = u.flmap, A = u.fdmap, b = 511, y = 31), 2 == p) {\n        m = a(e, F, 5) + 257, w = a(e, F + 5, 5) + 1, v = a(e, F + 10, 4) + 4, F += 14;\n\n        for (var _ = 0; _ < 38; _ += 2) u.itree[_] = 0, u.itree[_ + 1] = 0;\n\n        var B = 1;\n\n        for (_ = 0; _ < v; _++) {\n          var U = a(e, F + 3 * _, 3);\n          u.itree[1 + (u.ordr[_] << 1)] = U, U > B && (B = U);\n        }\n\n        F += 3 * v, f(u.itree, B), l(u.itree, B, u.imap), d = u.lmap, A = u.dmap, F = s(u.imap, (1 << B) - 1, m + w, e, F, u.ttree);\n\n        var C = i._copyOut(u.ttree, 0, m, u.ltree);\n\n        b = (1 << C) - 1;\n\n        var I = i._copyOut(u.ttree, m, w, u.dtree);\n\n        y = (1 << I) - 1, f(u.ltree, C), l(u.ltree, C, d), f(u.dtree, I), l(u.dtree, I, A);\n      }\n\n      for (;;) {\n        var Q = d[c(e, F) & b];\n        F += 15 & Q;\n        var M = Q >>> 4;\n        if (M >>> 8 == 0) t[E++] = M;else {\n          if (256 == M) break;\n          var x = E + M - 254;\n\n          if (M > 264) {\n            var S = u.ldef[M - 257];\n            x = E + (S >>> 3) + a(e, F, 7 & S), F += 7 & S;\n          }\n\n          var R = A[c(e, F) & y];\n          F += 15 & R;\n          var T = R >>> 4,\n              O = u.ddef[T],\n              P = (O >>> 4) + o(e, F, 15 & O);\n\n          for (F += 15 & O, h && (t = UZIP.F._check(t, E + (1 << 17))); E < x;) t[E] = t[E++ - P], t[E] = t[E++ - P], t[E] = t[E++ - P], t[E] = t[E++ - P];\n\n          E = x;\n        }\n      }\n    } else {\n      0 != (7 & F) && (F += 8 - (7 & F));\n      var H = 4 + (F >>> 3),\n          L = e[H - 4] | e[H - 3] << 8;\n      h && (t = UZIP.F._check(t, E + L)), t.set(new r(e.buffer, e.byteOffset + H, L), E), F = H + L << 3, E += L;\n    }\n\n    return t.length == E ? t : t.slice(0, E);\n  }, UZIP.F._check = function (e, t) {\n    var r = e.length;\n    if (t <= r) return e;\n    var i = new Uint8Array(Math.max(r << 1, t));\n    return i.set(e, 0), i;\n  }, UZIP.F._decodeTiny = function (e, t, r, i, o, a) {\n    for (var s = UZIP.F._bitsE, f = UZIP.F._get17, l = 0; l < r;) {\n      var c = e[f(i, o) & t];\n      o += 15 & c;\n      var u = c >>> 4;\n      if (u <= 15) a[l] = u, l++;else {\n        var h = 0,\n            d = 0;\n        16 == u ? (d = 3 + s(i, o, 2), o += 2, h = a[l - 1]) : 17 == u ? (d = 3 + s(i, o, 3), o += 3) : 18 == u && (d = 11 + s(i, o, 7), o += 7);\n\n        for (var A = l + d; l < A;) a[l] = h, l++;\n      }\n    }\n\n    return o;\n  }, UZIP.F._copyOut = function (e, t, r, i) {\n    for (var o = 0, a = 0, s = i.length >>> 1; a < r;) {\n      var f = e[a + t];\n      i[a << 1] = 0, i[1 + (a << 1)] = f, f > o && (o = f), a++;\n    }\n\n    for (; a < s;) i[a << 1] = 0, i[1 + (a << 1)] = 0, a++;\n\n    return o;\n  }, UZIP.F.makeCodes = function (e, t) {\n    for (var r, i, o, a, s = UZIP.F.U, f = e.length, l = s.bl_count, c = 0; c <= t; c++) l[c] = 0;\n\n    for (c = 1; c < f; c += 2) l[e[c]]++;\n\n    var u = s.next_code;\n\n    for (r = 0, l[0] = 0, i = 1; i <= t; i++) r = r + l[i - 1] << 1, u[i] = r;\n\n    for (o = 0; o < f; o += 2) 0 != (a = e[o + 1]) && (e[o] = u[a], u[a]++);\n  }, UZIP.F.codes2map = function (e, t, r) {\n    for (var i = e.length, o = UZIP.F.U.rev15, a = 0; a < i; a += 2) if (0 != e[a + 1]) for (var s = a >> 1, f = e[a + 1], l = s << 4 | f, c = t - f, u = e[a] << c, h = u + (1 << c); u != h;) {\n      r[o[u] >>> 15 - t] = l, u++;\n    }\n  }, UZIP.F.revCodes = function (e, t) {\n    for (var r = UZIP.F.U.rev15, i = 15 - t, o = 0; o < e.length; o += 2) {\n      var a = e[o] << t - e[o + 1];\n      e[o] = r[a] >>> i;\n    }\n  }, UZIP.F._putsE = function (e, t, r) {\n    r <<= 7 & t;\n    var i = t >>> 3;\n    e[i] |= r, e[i + 1] |= r >>> 8;\n  }, UZIP.F._putsF = function (e, t, r) {\n    r <<= 7 & t;\n    var i = t >>> 3;\n    e[i] |= r, e[i + 1] |= r >>> 8, e[i + 2] |= r >>> 16;\n  }, UZIP.F._bitsE = function (e, t, r) {\n    return (e[t >>> 3] | e[1 + (t >>> 3)] << 8) >>> (7 & t) & (1 << r) - 1;\n  }, UZIP.F._bitsF = function (e, t, r) {\n    return (e[t >>> 3] | e[1 + (t >>> 3)] << 8 | e[2 + (t >>> 3)] << 16) >>> (7 & t) & (1 << r) - 1;\n  }, UZIP.F._get17 = function (e, t) {\n    return (e[t >>> 3] | e[1 + (t >>> 3)] << 8 | e[2 + (t >>> 3)] << 16) >>> (7 & t);\n  }, UZIP.F._get25 = function (e, t) {\n    return (e[t >>> 3] | e[1 + (t >>> 3)] << 8 | e[2 + (t >>> 3)] << 16 | e[3 + (t >>> 3)] << 24) >>> (7 & t);\n  }, UZIP.F.U = (r = Uint16Array, i = Uint32Array, {\n    next_code: new r(16),\n    bl_count: new r(16),\n    ordr: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n    of0: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],\n    exb: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\n    ldef: new r(32),\n    df0: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],\n    dxb: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\n    ddef: new i(32),\n    flmap: new r(512),\n    fltree: [],\n    fdmap: new r(32),\n    fdtree: [],\n    lmap: new r(32768),\n    ltree: [],\n    ttree: [],\n    dmap: new r(32768),\n    dtree: [],\n    imap: new r(512),\n    itree: [],\n    rev15: new r(32768),\n    lhst: new i(286),\n    dhst: new i(30),\n    ihst: new i(19),\n    lits: new i(15e3),\n    strt: new r(65536),\n    prev: new r(32768)\n  }), function () {\n    for (var e = UZIP.F.U, t = 0; t < 32768; t++) {\n      var r = t;\n      r = (4278255360 & (r = (4042322160 & (r = (3435973836 & (r = (2863311530 & r) >>> 1 | (1431655765 & r) << 1)) >>> 2 | (858993459 & r) << 2)) >>> 4 | (252645135 & r) << 4)) >>> 8 | (16711935 & r) << 8, e.rev15[t] = (r >>> 16 | r << 16) >>> 17;\n    }\n\n    function pushV(e, t, r) {\n      for (; 0 != t--;) e.push(0, r);\n    }\n\n    for (t = 0; t < 32; t++) e.ldef[t] = e.of0[t] << 3 | e.exb[t], e.ddef[t] = e.df0[t] << 4 | e.dxb[t];\n\n    pushV(e.fltree, 144, 8), pushV(e.fltree, 112, 9), pushV(e.fltree, 24, 7), pushV(e.fltree, 8, 8), UZIP.F.makeCodes(e.fltree, 9), UZIP.F.codes2map(e.fltree, 9, e.flmap), UZIP.F.revCodes(e.fltree, 9), pushV(e.fdtree, 32, 5), UZIP.F.makeCodes(e.fdtree, 5), UZIP.F.codes2map(e.fdtree, 5, e.fdmap), UZIP.F.revCodes(e.fdtree, 5), pushV(e.itree, 19, 0), pushV(e.ltree, 286, 0), pushV(e.dtree, 30, 0), pushV(e.ttree, 320, 0);\n  }();\n}();\n\nvar UZIP = _mergeNamespaces({\n  __proto__: null,\n  default: e\n}, [e]);\n\nconst UPNG = function () {\n  var e = {\n    nextZero(e, t) {\n      for (; 0 != e[t];) t++;\n\n      return t;\n    },\n\n    readUshort: (e, t) => e[t] << 8 | e[t + 1],\n\n    writeUshort(e, t, r) {\n      e[t] = r >> 8 & 255, e[t + 1] = 255 & r;\n    },\n\n    readUint: (e, t) => 16777216 * e[t] + (e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]),\n\n    writeUint(e, t, r) {\n      e[t] = r >> 24 & 255, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = 255 & r;\n    },\n\n    readASCII(e, t, r) {\n      let i = \"\";\n\n      for (let o = 0; o < r; o++) i += String.fromCharCode(e[t + o]);\n\n      return i;\n    },\n\n    writeASCII(e, t, r) {\n      for (let i = 0; i < r.length; i++) e[t + i] = r.charCodeAt(i);\n    },\n\n    readBytes(e, t, r) {\n      const i = [];\n\n      for (let o = 0; o < r; o++) i.push(e[t + o]);\n\n      return i;\n    },\n\n    pad: e => e.length < 2 ? `0${e}` : e,\n\n    readUTF8(t, r, i) {\n      let o,\n          a = \"\";\n\n      for (let o = 0; o < i; o++) a += `%${e.pad(t[r + o].toString(16))}`;\n\n      try {\n        o = decodeURIComponent(a);\n      } catch (o) {\n        return e.readASCII(t, r, i);\n      }\n\n      return o;\n    }\n\n  };\n\n  function decodeImage(t, r, i, o) {\n    const a = r * i,\n          s = _getBPP(o),\n          f = Math.ceil(r * s / 8),\n          l = new Uint8Array(4 * a),\n          c = new Uint32Array(l.buffer),\n          {\n      ctype: u\n    } = o,\n          {\n      depth: h\n    } = o,\n          d = e.readUshort;\n\n    if (6 == u) {\n      const e = a << 2;\n      if (8 == h) for (var A = 0; A < e; A += 4) l[A] = t[A], l[A + 1] = t[A + 1], l[A + 2] = t[A + 2], l[A + 3] = t[A + 3];\n      if (16 == h) for (A = 0; A < e; A++) l[A] = t[A << 1];\n    } else if (2 == u) {\n      const e = o.tabs.tRNS;\n\n      if (null == e) {\n        if (8 == h) for (A = 0; A < a; A++) {\n          var g = 3 * A;\n          c[A] = 255 << 24 | t[g + 2] << 16 | t[g + 1] << 8 | t[g];\n        }\n        if (16 == h) for (A = 0; A < a; A++) {\n          g = 6 * A;\n          c[A] = 255 << 24 | t[g + 4] << 16 | t[g + 2] << 8 | t[g];\n        }\n      } else {\n        var p = e[0];\n        const r = e[1],\n              i = e[2];\n        if (8 == h) for (A = 0; A < a; A++) {\n          var m = A << 2;\n          g = 3 * A;\n          c[A] = 255 << 24 | t[g + 2] << 16 | t[g + 1] << 8 | t[g], t[g] == p && t[g + 1] == r && t[g + 2] == i && (l[m + 3] = 0);\n        }\n        if (16 == h) for (A = 0; A < a; A++) {\n          m = A << 2, g = 6 * A;\n          c[A] = 255 << 24 | t[g + 4] << 16 | t[g + 2] << 8 | t[g], d(t, g) == p && d(t, g + 2) == r && d(t, g + 4) == i && (l[m + 3] = 0);\n        }\n      }\n    } else if (3 == u) {\n      const e = o.tabs.PLTE,\n            s = o.tabs.tRNS,\n            c = s ? s.length : 0;\n      if (1 == h) for (var w = 0; w < i; w++) {\n        var v = w * f,\n            b = w * r;\n\n        for (A = 0; A < r; A++) {\n          m = b + A << 2;\n          var y = 3 * (E = t[v + (A >> 3)] >> 7 - ((7 & A) << 0) & 1);\n          l[m] = e[y], l[m + 1] = e[y + 1], l[m + 2] = e[y + 2], l[m + 3] = E < c ? s[E] : 255;\n        }\n      }\n      if (2 == h) for (w = 0; w < i; w++) for (v = w * f, b = w * r, A = 0; A < r; A++) {\n        m = b + A << 2, y = 3 * (E = t[v + (A >> 2)] >> 6 - ((3 & A) << 1) & 3);\n        l[m] = e[y], l[m + 1] = e[y + 1], l[m + 2] = e[y + 2], l[m + 3] = E < c ? s[E] : 255;\n      }\n      if (4 == h) for (w = 0; w < i; w++) for (v = w * f, b = w * r, A = 0; A < r; A++) {\n        m = b + A << 2, y = 3 * (E = t[v + (A >> 1)] >> 4 - ((1 & A) << 2) & 15);\n        l[m] = e[y], l[m + 1] = e[y + 1], l[m + 2] = e[y + 2], l[m + 3] = E < c ? s[E] : 255;\n      }\n      if (8 == h) for (A = 0; A < a; A++) {\n        var E;\n        m = A << 2, y = 3 * (E = t[A]);\n        l[m] = e[y], l[m + 1] = e[y + 1], l[m + 2] = e[y + 2], l[m + 3] = E < c ? s[E] : 255;\n      }\n    } else if (4 == u) {\n      if (8 == h) for (A = 0; A < a; A++) {\n        m = A << 2;\n        var F = t[_ = A << 1];\n        l[m] = F, l[m + 1] = F, l[m + 2] = F, l[m + 3] = t[_ + 1];\n      }\n      if (16 == h) for (A = 0; A < a; A++) {\n        var _;\n\n        m = A << 2, F = t[_ = A << 2];\n        l[m] = F, l[m + 1] = F, l[m + 2] = F, l[m + 3] = t[_ + 2];\n      }\n    } else if (0 == u) for (p = o.tabs.tRNS ? o.tabs.tRNS : -1, w = 0; w < i; w++) {\n      const e = w * f,\n            i = w * r;\n      if (1 == h) for (var B = 0; B < r; B++) {\n        var U = (F = 255 * (t[e + (B >>> 3)] >>> 7 - (7 & B) & 1)) == 255 * p ? 0 : 255;\n        c[i + B] = U << 24 | F << 16 | F << 8 | F;\n      } else if (2 == h) for (B = 0; B < r; B++) {\n        U = (F = 85 * (t[e + (B >>> 2)] >>> 6 - ((3 & B) << 1) & 3)) == 85 * p ? 0 : 255;\n        c[i + B] = U << 24 | F << 16 | F << 8 | F;\n      } else if (4 == h) for (B = 0; B < r; B++) {\n        U = (F = 17 * (t[e + (B >>> 1)] >>> 4 - ((1 & B) << 2) & 15)) == 17 * p ? 0 : 255;\n        c[i + B] = U << 24 | F << 16 | F << 8 | F;\n      } else if (8 == h) for (B = 0; B < r; B++) {\n        U = (F = t[e + B]) == p ? 0 : 255;\n        c[i + B] = U << 24 | F << 16 | F << 8 | F;\n      } else if (16 == h) for (B = 0; B < r; B++) {\n        F = t[e + (B << 1)], U = d(t, e + (B << 1)) == p ? 0 : 255;\n        c[i + B] = U << 24 | F << 16 | F << 8 | F;\n      }\n    }\n\n    return l;\n  }\n\n  function _decompress(e, r, i, o) {\n    const a = _getBPP(e),\n          s = Math.ceil(i * a / 8),\n          f = new Uint8Array((s + 1 + e.interlace) * o);\n\n    return r = e.tabs.CgBI ? t(r, f) : _inflate(r, f), 0 == e.interlace ? r = _filterZero(r, e, 0, i, o) : 1 == e.interlace && (r = function _readInterlace(e, t) {\n      const r = t.width,\n            i = t.height,\n            o = _getBPP(t),\n            a = o >> 3,\n            s = Math.ceil(r * o / 8),\n            f = new Uint8Array(i * s);\n\n      let l = 0;\n      const c = [0, 0, 4, 0, 2, 0, 1],\n            u = [0, 4, 0, 2, 0, 1, 0],\n            h = [8, 8, 8, 4, 4, 2, 2],\n            d = [8, 8, 4, 4, 2, 2, 1];\n      let A = 0;\n\n      for (; A < 7;) {\n        const p = h[A],\n              m = d[A];\n        let w = 0,\n            v = 0,\n            b = c[A];\n\n        for (; b < i;) b += p, v++;\n\n        let y = u[A];\n\n        for (; y < r;) y += m, w++;\n\n        const E = Math.ceil(w * o / 8);\n\n        _filterZero(e, t, l, w, v);\n\n        let F = 0,\n            _ = c[A];\n\n        for (; _ < i;) {\n          let t = u[A],\n              i = l + F * E << 3;\n\n          for (; t < r;) {\n            var g;\n            if (1 == o) g = (g = e[i >> 3]) >> 7 - (7 & i) & 1, f[_ * s + (t >> 3)] |= g << 7 - ((7 & t) << 0);\n            if (2 == o) g = (g = e[i >> 3]) >> 6 - (7 & i) & 3, f[_ * s + (t >> 2)] |= g << 6 - ((3 & t) << 1);\n            if (4 == o) g = (g = e[i >> 3]) >> 4 - (7 & i) & 15, f[_ * s + (t >> 1)] |= g << 4 - ((1 & t) << 2);\n\n            if (o >= 8) {\n              const r = _ * s + t * a;\n\n              for (let t = 0; t < a; t++) f[r + t] = e[(i >> 3) + t];\n            }\n\n            i += o, t += m;\n          }\n\n          F++, _ += p;\n        }\n\n        w * v != 0 && (l += v * (1 + E)), A += 1;\n      }\n\n      return f;\n    }(r, e)), r;\n  }\n\n  function _inflate(e, r) {\n    return t(new Uint8Array(e.buffer, 2, e.length - 6), r);\n  }\n\n  var t = function () {\n    const e = {\n      H: {}\n    };\n    return e.H.N = function (t, r) {\n      const i = Uint8Array;\n      let o,\n          a,\n          s = 0,\n          f = 0,\n          l = 0,\n          c = 0,\n          u = 0,\n          h = 0,\n          d = 0,\n          A = 0,\n          g = 0;\n      if (3 == t[0] && 0 == t[1]) return r || new i(0);\n\n      const p = e.H,\n            m = p.b,\n            w = p.e,\n            v = p.R,\n            b = p.n,\n            y = p.A,\n            E = p.Z,\n            F = p.m,\n            _ = null == r;\n\n      for (_ && (r = new i(t.length >>> 2 << 5)); 0 == s;) if (s = m(t, g, 1), f = m(t, g + 1, 2), g += 3, 0 != f) {\n        if (_ && (r = e.H.W(r, A + (1 << 17))), 1 == f && (o = F.J, a = F.h, h = 511, d = 31), 2 == f) {\n          l = w(t, g, 5) + 257, c = w(t, g + 5, 5) + 1, u = w(t, g + 10, 4) + 4, g += 14;\n          let e = 1;\n\n          for (var B = 0; B < 38; B += 2) F.Q[B] = 0, F.Q[B + 1] = 0;\n\n          for (B = 0; B < u; B++) {\n            const r = w(t, g + 3 * B, 3);\n            F.Q[1 + (F.X[B] << 1)] = r, r > e && (e = r);\n          }\n\n          g += 3 * u, b(F.Q, e), y(F.Q, e, F.u), o = F.w, a = F.d, g = v(F.u, (1 << e) - 1, l + c, t, g, F.v);\n          const r = p.V(F.v, 0, l, F.C);\n          h = (1 << r) - 1;\n          const i = p.V(F.v, l, c, F.D);\n          d = (1 << i) - 1, b(F.C, r), y(F.C, r, o), b(F.D, i), y(F.D, i, a);\n        }\n\n        for (;;) {\n          const e = o[E(t, g) & h];\n          g += 15 & e;\n          const i = e >>> 4;\n          if (i >>> 8 == 0) r[A++] = i;else {\n            if (256 == i) break;\n            {\n              let e = A + i - 254;\n\n              if (i > 264) {\n                const r = F.q[i - 257];\n                e = A + (r >>> 3) + w(t, g, 7 & r), g += 7 & r;\n              }\n\n              const o = a[E(t, g) & d];\n              g += 15 & o;\n              const s = o >>> 4,\n                    f = F.c[s],\n                    l = (f >>> 4) + m(t, g, 15 & f);\n\n              for (g += 15 & f; A < e;) r[A] = r[A++ - l], r[A] = r[A++ - l], r[A] = r[A++ - l], r[A] = r[A++ - l];\n\n              A = e;\n            }\n          }\n        }\n      } else {\n        0 != (7 & g) && (g += 8 - (7 & g));\n        const o = 4 + (g >>> 3),\n              a = t[o - 4] | t[o - 3] << 8;\n        _ && (r = e.H.W(r, A + a)), r.set(new i(t.buffer, t.byteOffset + o, a), A), g = o + a << 3, A += a;\n      }\n\n      return r.length == A ? r : r.slice(0, A);\n    }, e.H.W = function (e, t) {\n      const r = e.length;\n      if (t <= r) return e;\n      const i = new Uint8Array(r << 1);\n      return i.set(e, 0), i;\n    }, e.H.R = function (t, r, i, o, a, s) {\n      const f = e.H.e,\n            l = e.H.Z;\n      let c = 0;\n\n      for (; c < i;) {\n        const e = t[l(o, a) & r];\n        a += 15 & e;\n        const i = e >>> 4;\n        if (i <= 15) s[c] = i, c++;else {\n          let e = 0,\n              t = 0;\n          16 == i ? (t = 3 + f(o, a, 2), a += 2, e = s[c - 1]) : 17 == i ? (t = 3 + f(o, a, 3), a += 3) : 18 == i && (t = 11 + f(o, a, 7), a += 7);\n          const r = c + t;\n\n          for (; c < r;) s[c] = e, c++;\n        }\n      }\n\n      return a;\n    }, e.H.V = function (e, t, r, i) {\n      let o = 0,\n          a = 0;\n      const s = i.length >>> 1;\n\n      for (; a < r;) {\n        const r = e[a + t];\n        i[a << 1] = 0, i[1 + (a << 1)] = r, r > o && (o = r), a++;\n      }\n\n      for (; a < s;) i[a << 1] = 0, i[1 + (a << 1)] = 0, a++;\n\n      return o;\n    }, e.H.n = function (t, r) {\n      const i = e.H.m,\n            o = t.length;\n      let a, s, f;\n      let l;\n      const c = i.j;\n\n      for (var u = 0; u <= r; u++) c[u] = 0;\n\n      for (u = 1; u < o; u += 2) c[t[u]]++;\n\n      const h = i.K;\n\n      for (a = 0, c[0] = 0, s = 1; s <= r; s++) a = a + c[s - 1] << 1, h[s] = a;\n\n      for (f = 0; f < o; f += 2) l = t[f + 1], 0 != l && (t[f] = h[l], h[l]++);\n    }, e.H.A = function (t, r, i) {\n      const o = t.length,\n            a = e.H.m.r;\n\n      for (let e = 0; e < o; e += 2) if (0 != t[e + 1]) {\n        const o = e >> 1,\n              s = t[e + 1],\n              f = o << 4 | s,\n              l = r - s;\n        let c = t[e] << l;\n        const u = c + (1 << l);\n\n        for (; c != u;) {\n          i[a[c] >>> 15 - r] = f, c++;\n        }\n      }\n    }, e.H.l = function (t, r) {\n      const i = e.H.m.r,\n            o = 15 - r;\n\n      for (let e = 0; e < t.length; e += 2) {\n        const a = t[e] << r - t[e + 1];\n        t[e] = i[a] >>> o;\n      }\n    }, e.H.M = function (e, t, r) {\n      r <<= 7 & t;\n      const i = t >>> 3;\n      e[i] |= r, e[i + 1] |= r >>> 8;\n    }, e.H.I = function (e, t, r) {\n      r <<= 7 & t;\n      const i = t >>> 3;\n      e[i] |= r, e[i + 1] |= r >>> 8, e[i + 2] |= r >>> 16;\n    }, e.H.e = function (e, t, r) {\n      return (e[t >>> 3] | e[1 + (t >>> 3)] << 8) >>> (7 & t) & (1 << r) - 1;\n    }, e.H.b = function (e, t, r) {\n      return (e[t >>> 3] | e[1 + (t >>> 3)] << 8 | e[2 + (t >>> 3)] << 16) >>> (7 & t) & (1 << r) - 1;\n    }, e.H.Z = function (e, t) {\n      return (e[t >>> 3] | e[1 + (t >>> 3)] << 8 | e[2 + (t >>> 3)] << 16) >>> (7 & t);\n    }, e.H.i = function (e, t) {\n      return (e[t >>> 3] | e[1 + (t >>> 3)] << 8 | e[2 + (t >>> 3)] << 16 | e[3 + (t >>> 3)] << 24) >>> (7 & t);\n    }, e.H.m = function () {\n      const e = Uint16Array,\n            t = Uint32Array;\n      return {\n        K: new e(16),\n        j: new e(16),\n        X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],\n        S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999],\n        T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0],\n        q: new e(32),\n        p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535],\n        z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0],\n        c: new t(32),\n        J: new e(512),\n        _: [],\n        h: new e(32),\n        $: [],\n        w: new e(32768),\n        C: [],\n        v: [],\n        d: new e(32768),\n        D: [],\n        u: new e(512),\n        Q: [],\n        r: new e(32768),\n        s: new t(286),\n        Y: new t(30),\n        a: new t(19),\n        t: new t(15e3),\n        k: new e(65536),\n        g: new e(32768)\n      };\n    }(), function () {\n      const t = e.H.m;\n\n      for (var r = 0; r < 32768; r++) {\n        let e = r;\n        e = (2863311530 & e) >>> 1 | (1431655765 & e) << 1, e = (3435973836 & e) >>> 2 | (858993459 & e) << 2, e = (4042322160 & e) >>> 4 | (252645135 & e) << 4, e = (4278255360 & e) >>> 8 | (16711935 & e) << 8, t.r[r] = (e >>> 16 | e << 16) >>> 17;\n      }\n\n      function n(e, t, r) {\n        for (; 0 != t--;) e.push(0, r);\n      }\n\n      for (r = 0; r < 32; r++) t.q[r] = t.S[r] << 3 | t.T[r], t.c[r] = t.p[r] << 4 | t.z[r];\n\n      n(t._, 144, 8), n(t._, 112, 9), n(t._, 24, 7), n(t._, 8, 8), e.H.n(t._, 9), e.H.A(t._, 9, t.J), e.H.l(t._, 9), n(t.$, 32, 5), e.H.n(t.$, 5), e.H.A(t.$, 5, t.h), e.H.l(t.$, 5), n(t.Q, 19, 0), n(t.C, 286, 0), n(t.D, 30, 0), n(t.v, 320, 0);\n    }(), e.H.N;\n  }();\n\n  function _getBPP(e) {\n    return [1, null, 3, 1, 2, null, 4][e.ctype] * e.depth;\n  }\n\n  function _filterZero(e, t, r, i, o) {\n    let a = _getBPP(t);\n\n    const s = Math.ceil(i * a / 8);\n    let f, l;\n    a = Math.ceil(a / 8);\n    let c = e[r],\n        u = 0;\n    if (c > 1 && (e[r] = [0, 0, 1][c - 2]), 3 == c) for (u = a; u < s; u++) e[u + 1] = e[u + 1] + (e[u + 1 - a] >>> 1) & 255;\n\n    for (let t = 0; t < o; t++) if (f = r + t * s, l = f + t + 1, c = e[l - 1], u = 0, 0 == c) for (; u < s; u++) e[f + u] = e[l + u];else if (1 == c) {\n      for (; u < a; u++) e[f + u] = e[l + u];\n\n      for (; u < s; u++) e[f + u] = e[l + u] + e[f + u - a];\n    } else if (2 == c) for (; u < s; u++) e[f + u] = e[l + u] + e[f + u - s];else if (3 == c) {\n      for (; u < a; u++) e[f + u] = e[l + u] + (e[f + u - s] >>> 1);\n\n      for (; u < s; u++) e[f + u] = e[l + u] + (e[f + u - s] + e[f + u - a] >>> 1);\n    } else {\n      for (; u < a; u++) e[f + u] = e[l + u] + _paeth(0, e[f + u - s], 0);\n\n      for (; u < s; u++) e[f + u] = e[l + u] + _paeth(e[f + u - a], e[f + u - s], e[f + u - a - s]);\n    }\n\n    return e;\n  }\n\n  function _paeth(e, t, r) {\n    const i = e + t - r,\n          o = i - e,\n          a = i - t,\n          s = i - r;\n    return o * o <= a * a && o * o <= s * s ? e : a * a <= s * s ? t : r;\n  }\n\n  function _IHDR(t, r, i) {\n    i.width = e.readUint(t, r), r += 4, i.height = e.readUint(t, r), r += 4, i.depth = t[r], r++, i.ctype = t[r], r++, i.compress = t[r], r++, i.filter = t[r], r++, i.interlace = t[r], r++;\n  }\n\n  function _copyTile(e, t, r, i, o, a, s, f, l) {\n    const c = Math.min(t, o),\n          u = Math.min(r, a);\n    let h = 0,\n        d = 0;\n\n    for (let r = 0; r < u; r++) for (let a = 0; a < c; a++) if (s >= 0 && f >= 0 ? (h = r * t + a << 2, d = (f + r) * o + s + a << 2) : (h = (-f + r) * t - s + a << 2, d = r * o + a << 2), 0 == l) i[d] = e[h], i[d + 1] = e[h + 1], i[d + 2] = e[h + 2], i[d + 3] = e[h + 3];else if (1 == l) {\n      var A = e[h + 3] * (1 / 255),\n          g = e[h] * A,\n          p = e[h + 1] * A,\n          m = e[h + 2] * A,\n          w = i[d + 3] * (1 / 255),\n          v = i[d] * w,\n          b = i[d + 1] * w,\n          y = i[d + 2] * w;\n      const t = 1 - A,\n            r = A + w * t,\n            o = 0 == r ? 0 : 1 / r;\n      i[d + 3] = 255 * r, i[d + 0] = (g + v * t) * o, i[d + 1] = (p + b * t) * o, i[d + 2] = (m + y * t) * o;\n    } else if (2 == l) {\n      A = e[h + 3], g = e[h], p = e[h + 1], m = e[h + 2], w = i[d + 3], v = i[d], b = i[d + 1], y = i[d + 2];\n      A == w && g == v && p == b && m == y ? (i[d] = 0, i[d + 1] = 0, i[d + 2] = 0, i[d + 3] = 0) : (i[d] = g, i[d + 1] = p, i[d + 2] = m, i[d + 3] = A);\n    } else if (3 == l) {\n      A = e[h + 3], g = e[h], p = e[h + 1], m = e[h + 2], w = i[d + 3], v = i[d], b = i[d + 1], y = i[d + 2];\n      if (A == w && g == v && p == b && m == y) continue;\n      if (A < 220 && w > 20) return !1;\n    }\n\n    return !0;\n  }\n\n  return {\n    decode: function decode(r) {\n      const i = new Uint8Array(r);\n      let o = 8;\n      const a = e,\n            s = a.readUshort,\n            f = a.readUint,\n            l = {\n        tabs: {},\n        frames: []\n      },\n            c = new Uint8Array(i.length);\n      let u,\n          h = 0,\n          d = 0;\n      const A = [137, 80, 78, 71, 13, 10, 26, 10];\n\n      for (var g = 0; g < 8; g++) if (i[g] != A[g]) throw \"The input is not a PNG file!\";\n\n      for (; o < i.length;) {\n        const e = a.readUint(i, o);\n        o += 4;\n        const r = a.readASCII(i, o, 4);\n        if (o += 4, \"IHDR\" == r) _IHDR(i, o, l);else if (\"iCCP\" == r) {\n          for (var p = o; 0 != i[p];) p++;\n\n          a.readASCII(i, o, p - o), i[p + 1];\n          const s = i.slice(p + 2, o + e);\n          let f = null;\n\n          try {\n            f = _inflate(s);\n          } catch (e) {\n            f = t(s);\n          }\n\n          l.tabs[r] = f;\n        } else if (\"CgBI\" == r) l.tabs[r] = i.slice(o, o + 4);else if (\"IDAT\" == r) {\n          for (g = 0; g < e; g++) c[h + g] = i[o + g];\n\n          h += e;\n        } else if (\"acTL\" == r) l.tabs[r] = {\n          num_frames: f(i, o),\n          num_plays: f(i, o + 4)\n        }, u = new Uint8Array(i.length);else if (\"fcTL\" == r) {\n          if (0 != d) (E = l.frames[l.frames.length - 1]).data = _decompress(l, u.slice(0, d), E.rect.width, E.rect.height), d = 0;\n          const e = {\n            x: f(i, o + 12),\n            y: f(i, o + 16),\n            width: f(i, o + 4),\n            height: f(i, o + 8)\n          };\n          let t = s(i, o + 22);\n          t = s(i, o + 20) / (0 == t ? 100 : t);\n          const r = {\n            rect: e,\n            delay: Math.round(1e3 * t),\n            dispose: i[o + 24],\n            blend: i[o + 25]\n          };\n          l.frames.push(r);\n        } else if (\"fdAT\" == r) {\n          for (g = 0; g < e - 4; g++) u[d + g] = i[o + g + 4];\n\n          d += e - 4;\n        } else if (\"pHYs\" == r) l.tabs[r] = [a.readUint(i, o), a.readUint(i, o + 4), i[o + 8]];else if (\"cHRM\" == r) {\n          l.tabs[r] = [];\n\n          for (g = 0; g < 8; g++) l.tabs[r].push(a.readUint(i, o + 4 * g));\n        } else if (\"tEXt\" == r || \"zTXt\" == r) {\n          null == l.tabs[r] && (l.tabs[r] = {});\n          var m = a.nextZero(i, o),\n              w = a.readASCII(i, o, m - o),\n              v = o + e - m - 1;\n          if (\"tEXt\" == r) y = a.readASCII(i, m + 1, v);else {\n            var b = _inflate(i.slice(m + 2, m + 2 + v));\n\n            y = a.readUTF8(b, 0, b.length);\n          }\n          l.tabs[r][w] = y;\n        } else if (\"iTXt\" == r) {\n          null == l.tabs[r] && (l.tabs[r] = {});\n          m = 0, p = o;\n          m = a.nextZero(i, p);\n          w = a.readASCII(i, p, m - p);\n          const t = i[p = m + 1];\n          var y;\n          i[p + 1], p += 2, m = a.nextZero(i, p), a.readASCII(i, p, m - p), p = m + 1, m = a.nextZero(i, p), a.readUTF8(i, p, m - p);\n          v = e - ((p = m + 1) - o);\n          if (0 == t) y = a.readUTF8(i, p, v);else {\n            b = _inflate(i.slice(p, p + v));\n            y = a.readUTF8(b, 0, b.length);\n          }\n          l.tabs[r][w] = y;\n        } else if (\"PLTE\" == r) l.tabs[r] = a.readBytes(i, o, e);else if (\"hIST\" == r) {\n          const e = l.tabs.PLTE.length / 3;\n          l.tabs[r] = [];\n\n          for (g = 0; g < e; g++) l.tabs[r].push(s(i, o + 2 * g));\n        } else if (\"tRNS\" == r) 3 == l.ctype ? l.tabs[r] = a.readBytes(i, o, e) : 0 == l.ctype ? l.tabs[r] = s(i, o) : 2 == l.ctype && (l.tabs[r] = [s(i, o), s(i, o + 2), s(i, o + 4)]);else if (\"gAMA\" == r) l.tabs[r] = a.readUint(i, o) / 1e5;else if (\"sRGB\" == r) l.tabs[r] = i[o];else if (\"bKGD\" == r) 0 == l.ctype || 4 == l.ctype ? l.tabs[r] = [s(i, o)] : 2 == l.ctype || 6 == l.ctype ? l.tabs[r] = [s(i, o), s(i, o + 2), s(i, o + 4)] : 3 == l.ctype && (l.tabs[r] = i[o]);else if (\"IEND\" == r) break;\n        o += e, a.readUint(i, o), o += 4;\n      }\n\n      var E;\n      return 0 != d && ((E = l.frames[l.frames.length - 1]).data = _decompress(l, u.slice(0, d), E.rect.width, E.rect.height)), l.data = _decompress(l, c, l.width, l.height), delete l.compress, delete l.interlace, delete l.filter, l;\n    },\n    toRGBA8: function toRGBA8(e) {\n      const t = e.width,\n            r = e.height;\n      if (null == e.tabs.acTL) return [decodeImage(e.data, t, r, e).buffer];\n      const i = [];\n      null == e.frames[0].data && (e.frames[0].data = e.data);\n      const o = t * r * 4,\n            a = new Uint8Array(o),\n            s = new Uint8Array(o),\n            f = new Uint8Array(o);\n\n      for (let c = 0; c < e.frames.length; c++) {\n        const u = e.frames[c],\n              h = u.rect.x,\n              d = u.rect.y,\n              A = u.rect.width,\n              g = u.rect.height,\n              p = decodeImage(u.data, A, g, e);\n        if (0 != c) for (var l = 0; l < o; l++) f[l] = a[l];\n        if (0 == u.blend ? _copyTile(p, A, g, a, t, r, h, d, 0) : 1 == u.blend && _copyTile(p, A, g, a, t, r, h, d, 1), i.push(a.buffer.slice(0)), 0 == u.dispose) ;else if (1 == u.dispose) _copyTile(s, A, g, a, t, r, h, d, 0);else if (2 == u.dispose) for (l = 0; l < o; l++) a[l] = f[l];\n      }\n\n      return i;\n    },\n    _paeth: _paeth,\n    _copyTile: _copyTile,\n    _bin: e\n  };\n}();\n\n!function () {\n  const {\n    _copyTile: e\n  } = UPNG,\n        {\n    _bin: t\n  } = UPNG,\n        r = UPNG._paeth;\n  var i = {\n    table: function () {\n      const e = new Uint32Array(256);\n\n      for (let t = 0; t < 256; t++) {\n        let r = t;\n\n        for (let e = 0; e < 8; e++) 1 & r ? r = 3988292384 ^ r >>> 1 : r >>>= 1;\n\n        e[t] = r;\n      }\n\n      return e;\n    }(),\n\n    update(e, t, r, o) {\n      for (let a = 0; a < o; a++) e = i.table[255 & (e ^ t[r + a])] ^ e >>> 8;\n\n      return e;\n    },\n\n    crc: (e, t, r) => 4294967295 ^ i.update(4294967295, e, t, r)\n  };\n\n  function addErr(e, t, r, i) {\n    t[r] += e[0] * i >> 4, t[r + 1] += e[1] * i >> 4, t[r + 2] += e[2] * i >> 4, t[r + 3] += e[3] * i >> 4;\n  }\n\n  function N(e) {\n    return Math.max(0, Math.min(255, e));\n  }\n\n  function D(e, t) {\n    const r = e[0] - t[0],\n          i = e[1] - t[1],\n          o = e[2] - t[2],\n          a = e[3] - t[3];\n    return r * r + i * i + o * o + a * a;\n  }\n\n  function dither(e, t, r, i, o, a, s) {\n    null == s && (s = 1);\n    const f = i.length,\n          l = [];\n\n    for (var c = 0; c < f; c++) {\n      const e = i[c];\n      l.push([e >>> 0 & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24 & 255]);\n    }\n\n    for (c = 0; c < f; c++) {\n      let e = 4294967295;\n\n      for (var u = 0, h = 0; h < f; h++) {\n        var d = D(l[c], l[h]);\n        h != c && d < e && (e = d, u = h);\n      }\n    }\n\n    const A = new Uint32Array(o.buffer),\n          g = new Int16Array(t * r * 4),\n          p = [0, 8, 2, 10, 12, 4, 14, 6, 3, 11, 1, 9, 15, 7, 13, 5];\n\n    for (c = 0; c < p.length; c++) p[c] = 255 * ((p[c] + .5) / 16 - .5);\n\n    for (let o = 0; o < r; o++) for (let w = 0; w < t; w++) {\n      var m;\n      c = 4 * (o * t + w);\n      if (2 != s) m = [N(e[c] + g[c]), N(e[c + 1] + g[c + 1]), N(e[c + 2] + g[c + 2]), N(e[c + 3] + g[c + 3])];else {\n        d = p[4 * (3 & o) + (3 & w)];\n        m = [N(e[c] + d), N(e[c + 1] + d), N(e[c + 2] + d), N(e[c + 3] + d)];\n      }\n      u = 0;\n      let v = 16777215;\n\n      for (h = 0; h < f; h++) {\n        const e = D(m, l[h]);\n        e < v && (v = e, u = h);\n      }\n\n      const b = l[u],\n            y = [m[0] - b[0], m[1] - b[1], m[2] - b[2], m[3] - b[3]];\n      1 == s && (w != t - 1 && addErr(y, g, c + 4, 7), o != r - 1 && (0 != w && addErr(y, g, c + 4 * t - 4, 3), addErr(y, g, c + 4 * t, 5), w != t - 1 && addErr(y, g, c + 4 * t + 4, 1))), a[c >> 2] = u, A[c >> 2] = i[u];\n    }\n  }\n\n  function _main(e, r, o, a, s) {\n    null == s && (s = {});\n    const {\n      crc: f\n    } = i,\n          l = t.writeUint,\n          c = t.writeUshort,\n          u = t.writeASCII;\n    let h = 8;\n    const d = e.frames.length > 1;\n    let A,\n        g = !1,\n        p = 33 + (d ? 20 : 0);\n\n    if (null != s.sRGB && (p += 13), null != s.pHYs && (p += 21), null != s.iCCP && (A = pako.deflate(s.iCCP), p += 21 + A.length + 4), 3 == e.ctype) {\n      for (var m = e.plte.length, w = 0; w < m; w++) e.plte[w] >>> 24 != 255 && (g = !0);\n\n      p += 8 + 3 * m + 4 + (g ? 8 + 1 * m + 4 : 0);\n    }\n\n    for (var v = 0; v < e.frames.length; v++) {\n      d && (p += 38), p += (F = e.frames[v]).cimg.length + 12, 0 != v && (p += 4);\n    }\n\n    p += 12;\n    const b = new Uint8Array(p),\n          y = [137, 80, 78, 71, 13, 10, 26, 10];\n\n    for (w = 0; w < 8; w++) b[w] = y[w];\n\n    if (l(b, h, 13), h += 4, u(b, h, \"IHDR\"), h += 4, l(b, h, r), h += 4, l(b, h, o), h += 4, b[h] = e.depth, h++, b[h] = e.ctype, h++, b[h] = 0, h++, b[h] = 0, h++, b[h] = 0, h++, l(b, h, f(b, h - 17, 17)), h += 4, null != s.sRGB && (l(b, h, 1), h += 4, u(b, h, \"sRGB\"), h += 4, b[h] = s.sRGB, h++, l(b, h, f(b, h - 5, 5)), h += 4), null != s.iCCP) {\n      const e = 13 + A.length;\n      l(b, h, e), h += 4, u(b, h, \"iCCP\"), h += 4, u(b, h, \"ICC profile\"), h += 11, h += 2, b.set(A, h), h += A.length, l(b, h, f(b, h - (e + 4), e + 4)), h += 4;\n    }\n\n    if (null != s.pHYs && (l(b, h, 9), h += 4, u(b, h, \"pHYs\"), h += 4, l(b, h, s.pHYs[0]), h += 4, l(b, h, s.pHYs[1]), h += 4, b[h] = s.pHYs[2], h++, l(b, h, f(b, h - 13, 13)), h += 4), d && (l(b, h, 8), h += 4, u(b, h, \"acTL\"), h += 4, l(b, h, e.frames.length), h += 4, l(b, h, null != s.loop ? s.loop : 0), h += 4, l(b, h, f(b, h - 12, 12)), h += 4), 3 == e.ctype) {\n      l(b, h, 3 * (m = e.plte.length)), h += 4, u(b, h, \"PLTE\"), h += 4;\n\n      for (w = 0; w < m; w++) {\n        const t = 3 * w,\n              r = e.plte[w],\n              i = 255 & r,\n              o = r >>> 8 & 255,\n              a = r >>> 16 & 255;\n        b[h + t + 0] = i, b[h + t + 1] = o, b[h + t + 2] = a;\n      }\n\n      if (h += 3 * m, l(b, h, f(b, h - 3 * m - 4, 3 * m + 4)), h += 4, g) {\n        l(b, h, m), h += 4, u(b, h, \"tRNS\"), h += 4;\n\n        for (w = 0; w < m; w++) b[h + w] = e.plte[w] >>> 24 & 255;\n\n        h += m, l(b, h, f(b, h - m - 4, m + 4)), h += 4;\n      }\n    }\n\n    let E = 0;\n\n    for (v = 0; v < e.frames.length; v++) {\n      var F = e.frames[v];\n      d && (l(b, h, 26), h += 4, u(b, h, \"fcTL\"), h += 4, l(b, h, E++), h += 4, l(b, h, F.rect.width), h += 4, l(b, h, F.rect.height), h += 4, l(b, h, F.rect.x), h += 4, l(b, h, F.rect.y), h += 4, c(b, h, a[v]), h += 2, c(b, h, 1e3), h += 2, b[h] = F.dispose, h++, b[h] = F.blend, h++, l(b, h, f(b, h - 30, 30)), h += 4);\n      const t = F.cimg;\n      l(b, h, (m = t.length) + (0 == v ? 0 : 4)), h += 4;\n      const r = h;\n      u(b, h, 0 == v ? \"IDAT\" : \"fdAT\"), h += 4, 0 != v && (l(b, h, E++), h += 4), b.set(t, h), h += m, l(b, h, f(b, r, h - r)), h += 4;\n    }\n\n    return l(b, h, 0), h += 4, u(b, h, \"IEND\"), h += 4, l(b, h, f(b, h - 4, 4)), h += 4, b.buffer;\n  }\n\n  function compressPNG(e, t, r) {\n    for (let i = 0; i < e.frames.length; i++) {\n      const o = e.frames[i];\n      o.rect.width;\n      const a = o.rect.height,\n            s = new Uint8Array(a * o.bpl + a);\n      o.cimg = _filterZero(o.img, a, o.bpp, o.bpl, s, t, r);\n    }\n  }\n\n  function compress(t, r, i, o, a) {\n    const s = a[0],\n          f = a[1],\n          l = a[2],\n          c = a[3],\n          u = a[4],\n          h = a[5];\n    let d = 6,\n        A = 8,\n        g = 255;\n\n    for (var p = 0; p < t.length; p++) {\n      const e = new Uint8Array(t[p]);\n\n      for (var m = e.length, w = 0; w < m; w += 4) g &= e[w + 3];\n    }\n\n    const v = 255 != g,\n          b = function framize(t, r, i, o, a, s) {\n      const f = [];\n\n      for (var l = 0; l < t.length; l++) {\n        const h = new Uint8Array(t[l]),\n              A = new Uint32Array(h.buffer);\n        var c;\n        let g = 0,\n            p = 0,\n            m = r,\n            w = i,\n            v = o ? 1 : 0;\n\n        if (0 != l) {\n          const b = s || o || 1 == l || 0 != f[l - 2].dispose ? 1 : 2;\n          let y = 0,\n              E = 1e9;\n\n          for (let e = 0; e < b; e++) {\n            var u = new Uint8Array(t[l - 1 - e]);\n            const o = new Uint32Array(t[l - 1 - e]);\n            let s = r,\n                f = i,\n                c = -1,\n                h = -1;\n\n            for (let e = 0; e < i; e++) for (let t = 0; t < r; t++) {\n              A[d = e * r + t] != o[d] && (t < s && (s = t), t > c && (c = t), e < f && (f = e), e > h && (h = e));\n            }\n\n            -1 == c && (s = f = c = h = 0), a && (1 == (1 & s) && s--, 1 == (1 & f) && f--);\n            const v = (c - s + 1) * (h - f + 1);\n            v < E && (E = v, y = e, g = s, p = f, m = c - s + 1, w = h - f + 1);\n          }\n\n          u = new Uint8Array(t[l - 1 - y]);\n          1 == y && (f[l - 1].dispose = 2), c = new Uint8Array(m * w * 4), e(u, r, i, c, m, w, -g, -p, 0), v = e(h, r, i, c, m, w, -g, -p, 3) ? 1 : 0, 1 == v ? _prepareDiff(h, r, i, c, {\n            x: g,\n            y: p,\n            width: m,\n            height: w\n          }) : e(h, r, i, c, m, w, -g, -p, 0);\n        } else c = h.slice(0);\n\n        f.push({\n          rect: {\n            x: g,\n            y: p,\n            width: m,\n            height: w\n          },\n          img: c,\n          blend: v,\n          dispose: 0\n        });\n      }\n\n      if (o) for (l = 0; l < f.length; l++) {\n        if (1 == (A = f[l]).blend) continue;\n        const e = A.rect,\n              o = f[l - 1].rect,\n              s = Math.min(e.x, o.x),\n              c = Math.min(e.y, o.y),\n              u = {\n          x: s,\n          y: c,\n          width: Math.max(e.x + e.width, o.x + o.width) - s,\n          height: Math.max(e.y + e.height, o.y + o.height) - c\n        };\n        f[l - 1].dispose = 1, l - 1 != 0 && _updateFrame(t, r, i, f, l - 1, u, a), _updateFrame(t, r, i, f, l, u, a);\n      }\n      let h = 0;\n      if (1 != t.length) for (var d = 0; d < f.length; d++) {\n        var A;\n        h += (A = f[d]).rect.width * A.rect.height;\n      }\n      return f;\n    }(t, r, i, s, f, l),\n          y = {},\n          E = [],\n          F = [];\n\n    if (0 != o) {\n      const e = [];\n\n      for (w = 0; w < b.length; w++) e.push(b[w].img.buffer);\n\n      const t = function concatRGBA(e) {\n        let t = 0;\n\n        for (var r = 0; r < e.length; r++) t += e[r].byteLength;\n\n        const i = new Uint8Array(t);\n        let o = 0;\n\n        for (r = 0; r < e.length; r++) {\n          const t = new Uint8Array(e[r]),\n                a = t.length;\n\n          for (let e = 0; e < a; e += 4) {\n            let r = t[e],\n                a = t[e + 1],\n                s = t[e + 2];\n            const f = t[e + 3];\n            0 == f && (r = a = s = 0), i[o + e] = r, i[o + e + 1] = a, i[o + e + 2] = s, i[o + e + 3] = f;\n          }\n\n          o += a;\n        }\n\n        return i.buffer;\n      }(e),\n            r = quantize(t, o);\n\n      for (w = 0; w < r.plte.length; w++) E.push(r.plte[w].est.rgba);\n\n      let i = 0;\n\n      for (w = 0; w < b.length; w++) {\n        const e = (B = b[w]).img.length;\n\n        var _ = new Uint8Array(r.inds.buffer, i >> 2, e >> 2);\n\n        F.push(_);\n        const t = new Uint8Array(r.abuf, i, e);\n        h && dither(B.img, B.rect.width, B.rect.height, E, t, _), B.img.set(t), i += e;\n      }\n    } else for (p = 0; p < b.length; p++) {\n      var B = b[p];\n      const e = new Uint32Array(B.img.buffer);\n      var U = B.rect.width;\n      m = e.length, _ = new Uint8Array(m);\n      F.push(_);\n\n      for (w = 0; w < m; w++) {\n        const t = e[w];\n        if (0 != w && t == e[w - 1]) _[w] = _[w - 1];else if (w > U && t == e[w - U]) _[w] = _[w - U];else {\n          let e = y[t];\n          if (null == e && (y[t] = e = E.length, E.push(t), E.length >= 300)) break;\n          _[w] = e;\n        }\n      }\n    }\n\n    const C = E.length;\n    C <= 256 && 0 == u && (A = C <= 2 ? 1 : C <= 4 ? 2 : C <= 16 ? 4 : 8, A = Math.max(A, c));\n\n    for (p = 0; p < b.length; p++) {\n      (B = b[p]).rect.x, B.rect.y;\n      U = B.rect.width;\n      const e = B.rect.height;\n      let t = B.img;\n      new Uint32Array(t.buffer);\n      let r = 4 * U,\n          i = 4;\n\n      if (C <= 256 && 0 == u) {\n        r = Math.ceil(A * U / 8);\n        var I = new Uint8Array(r * e);\n        const o = F[p];\n\n        for (let t = 0; t < e; t++) {\n          w = t * r;\n          const e = t * U;\n          if (8 == A) for (var Q = 0; Q < U; Q++) I[w + Q] = o[e + Q];else if (4 == A) for (Q = 0; Q < U; Q++) I[w + (Q >> 1)] |= o[e + Q] << 4 - 4 * (1 & Q);else if (2 == A) for (Q = 0; Q < U; Q++) I[w + (Q >> 2)] |= o[e + Q] << 6 - 2 * (3 & Q);else if (1 == A) for (Q = 0; Q < U; Q++) I[w + (Q >> 3)] |= o[e + Q] << 7 - 1 * (7 & Q);\n        }\n\n        t = I, d = 3, i = 1;\n      } else if (0 == v && 1 == b.length) {\n        I = new Uint8Array(U * e * 3);\n        const o = U * e;\n\n        for (w = 0; w < o; w++) {\n          const e = 3 * w,\n                r = 4 * w;\n          I[e] = t[r], I[e + 1] = t[r + 1], I[e + 2] = t[r + 2];\n        }\n\n        t = I, d = 2, i = 3, r = 3 * U;\n      }\n\n      B.img = t, B.bpl = r, B.bpp = i;\n    }\n\n    return {\n      ctype: d,\n      depth: A,\n      plte: E,\n      frames: b\n    };\n  }\n\n  function _updateFrame(t, r, i, o, a, s, f) {\n    const l = Uint8Array,\n          c = Uint32Array,\n          u = new l(t[a - 1]),\n          h = new c(t[a - 1]),\n          d = a + 1 < t.length ? new l(t[a + 1]) : null,\n          A = new l(t[a]),\n          g = new c(A.buffer);\n    let p = r,\n        m = i,\n        w = -1,\n        v = -1;\n\n    for (let e = 0; e < s.height; e++) for (let t = 0; t < s.width; t++) {\n      const i = s.x + t,\n            f = s.y + e,\n            l = f * r + i,\n            c = g[l];\n      0 == c || 0 == o[a - 1].dispose && h[l] == c && (null == d || 0 != d[4 * l + 3]) || (i < p && (p = i), i > w && (w = i), f < m && (m = f), f > v && (v = f));\n    }\n\n    -1 == w && (p = m = w = v = 0), f && (1 == (1 & p) && p--, 1 == (1 & m) && m--), s = {\n      x: p,\n      y: m,\n      width: w - p + 1,\n      height: v - m + 1\n    };\n    const b = o[a];\n    b.rect = s, b.blend = 1, b.img = new Uint8Array(s.width * s.height * 4), 0 == o[a - 1].dispose ? (e(u, r, i, b.img, s.width, s.height, -s.x, -s.y, 0), _prepareDiff(A, r, i, b.img, s)) : e(A, r, i, b.img, s.width, s.height, -s.x, -s.y, 0);\n  }\n\n  function _prepareDiff(t, r, i, o, a) {\n    e(t, r, i, o, a.width, a.height, -a.x, -a.y, 2);\n  }\n\n  function _filterZero(e, t, r, i, o, a, s) {\n    const f = [];\n    let l,\n        c = [0, 1, 2, 3, 4];\n    -1 != a ? c = [a] : (t * i > 5e5 || 1 == r) && (c = [0]), s && (l = {\n      level: 0\n    });\n    const u = UZIP;\n\n    for (var h = 0; h < c.length; h++) {\n      for (let a = 0; a < t; a++) _filterLine(o, e, a, i, r, c[h]);\n\n      f.push(u.deflate(o, l));\n    }\n\n    let d,\n        A = 1e9;\n\n    for (h = 0; h < f.length; h++) f[h].length < A && (d = h, A = f[h].length);\n\n    return f[d];\n  }\n\n  function _filterLine(e, t, i, o, a, s) {\n    const f = i * o;\n    let l = f + i;\n    if (e[l] = s, l++, 0 == s) {\n      if (o < 500) for (var c = 0; c < o; c++) e[l + c] = t[f + c];else e.set(new Uint8Array(t.buffer, f, o), l);\n    } else if (1 == s) {\n      for (c = 0; c < a; c++) e[l + c] = t[f + c];\n\n      for (c = a; c < o; c++) e[l + c] = t[f + c] - t[f + c - a] + 256 & 255;\n    } else if (0 == i) {\n      for (c = 0; c < a; c++) e[l + c] = t[f + c];\n\n      if (2 == s) for (c = a; c < o; c++) e[l + c] = t[f + c];\n      if (3 == s) for (c = a; c < o; c++) e[l + c] = t[f + c] - (t[f + c - a] >> 1) + 256 & 255;\n      if (4 == s) for (c = a; c < o; c++) e[l + c] = t[f + c] - r(t[f + c - a], 0, 0) + 256 & 255;\n    } else {\n      if (2 == s) for (c = 0; c < o; c++) e[l + c] = t[f + c] + 256 - t[f + c - o] & 255;\n\n      if (3 == s) {\n        for (c = 0; c < a; c++) e[l + c] = t[f + c] + 256 - (t[f + c - o] >> 1) & 255;\n\n        for (c = a; c < o; c++) e[l + c] = t[f + c] + 256 - (t[f + c - o] + t[f + c - a] >> 1) & 255;\n      }\n\n      if (4 == s) {\n        for (c = 0; c < a; c++) e[l + c] = t[f + c] + 256 - r(0, t[f + c - o], 0) & 255;\n\n        for (c = a; c < o; c++) e[l + c] = t[f + c] + 256 - r(t[f + c - a], t[f + c - o], t[f + c - a - o]) & 255;\n      }\n    }\n  }\n\n  function quantize(e, t) {\n    const r = new Uint8Array(e),\n          i = r.slice(0),\n          o = new Uint32Array(i.buffer),\n          a = getKDtree(i, t),\n          s = a[0],\n          f = a[1],\n          l = r.length,\n          c = new Uint8Array(l >> 2);\n    let u;\n    if (r.length < 2e7) for (var h = 0; h < l; h += 4) {\n      u = getNearest(s, d = r[h] * (1 / 255), A = r[h + 1] * (1 / 255), g = r[h + 2] * (1 / 255), p = r[h + 3] * (1 / 255)), c[h >> 2] = u.ind, o[h >> 2] = u.est.rgba;\n    } else for (h = 0; h < l; h += 4) {\n      var d = r[h] * (1 / 255),\n          A = r[h + 1] * (1 / 255),\n          g = r[h + 2] * (1 / 255),\n          p = r[h + 3] * (1 / 255);\n\n      for (u = s; u.left;) u = planeDst(u.est, d, A, g, p) <= 0 ? u.left : u.right;\n\n      c[h >> 2] = u.ind, o[h >> 2] = u.est.rgba;\n    }\n    return {\n      abuf: i.buffer,\n      inds: c,\n      plte: f\n    };\n  }\n\n  function getKDtree(e, t, r) {\n    null == r && (r = 1e-4);\n    const i = new Uint32Array(e.buffer),\n          o = {\n      i0: 0,\n      i1: e.length,\n      bst: null,\n      est: null,\n      tdst: 0,\n      left: null,\n      right: null\n    };\n    o.bst = stats(e, o.i0, o.i1), o.est = estats(o.bst);\n    const a = [o];\n\n    for (; a.length < t;) {\n      let t = 0,\n          o = 0;\n\n      for (var s = 0; s < a.length; s++) a[s].est.L > t && (t = a[s].est.L, o = s);\n\n      if (t < r) break;\n      const f = a[o],\n            l = splitPixels(e, i, f.i0, f.i1, f.est.e, f.est.eMq255);\n\n      if (f.i0 >= l || f.i1 <= l) {\n        f.est.L = 0;\n        continue;\n      }\n\n      const c = {\n        i0: f.i0,\n        i1: l,\n        bst: null,\n        est: null,\n        tdst: 0,\n        left: null,\n        right: null\n      };\n      c.bst = stats(e, c.i0, c.i1), c.est = estats(c.bst);\n      const u = {\n        i0: l,\n        i1: f.i1,\n        bst: null,\n        est: null,\n        tdst: 0,\n        left: null,\n        right: null\n      };\n      u.bst = {\n        R: [],\n        m: [],\n        N: f.bst.N - c.bst.N\n      };\n\n      for (s = 0; s < 16; s++) u.bst.R[s] = f.bst.R[s] - c.bst.R[s];\n\n      for (s = 0; s < 4; s++) u.bst.m[s] = f.bst.m[s] - c.bst.m[s];\n\n      u.est = estats(u.bst), f.left = c, f.right = u, a[o] = c, a.push(u);\n    }\n\n    a.sort((e, t) => t.bst.N - e.bst.N);\n\n    for (s = 0; s < a.length; s++) a[s].ind = s;\n\n    return [o, a];\n  }\n\n  function getNearest(e, t, r, i, o) {\n    if (null == e.left) return e.tdst = function dist(e, t, r, i, o) {\n      const a = t - e[0],\n            s = r - e[1],\n            f = i - e[2],\n            l = o - e[3];\n      return a * a + s * s + f * f + l * l;\n    }(e.est.q, t, r, i, o), e;\n    const a = planeDst(e.est, t, r, i, o);\n    let s = e.left,\n        f = e.right;\n    a > 0 && (s = e.right, f = e.left);\n    const l = getNearest(s, t, r, i, o);\n    if (l.tdst <= a * a) return l;\n    const c = getNearest(f, t, r, i, o);\n    return c.tdst < l.tdst ? c : l;\n  }\n\n  function planeDst(e, t, r, i, o) {\n    const {\n      e: a\n    } = e;\n    return a[0] * t + a[1] * r + a[2] * i + a[3] * o - e.eMq;\n  }\n\n  function splitPixels(e, t, r, i, o, a) {\n    for (i -= 4; r < i;) {\n      for (; vecDot(e, r, o) <= a;) r += 4;\n\n      for (; vecDot(e, i, o) > a;) i -= 4;\n\n      if (r >= i) break;\n      const s = t[r >> 2];\n      t[r >> 2] = t[i >> 2], t[i >> 2] = s, r += 4, i -= 4;\n    }\n\n    for (; vecDot(e, r, o) > a;) r -= 4;\n\n    return r + 4;\n  }\n\n  function vecDot(e, t, r) {\n    return e[t] * r[0] + e[t + 1] * r[1] + e[t + 2] * r[2] + e[t + 3] * r[3];\n  }\n\n  function stats(e, t, r) {\n    const i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n          o = [0, 0, 0, 0],\n          a = r - t >> 2;\n\n    for (let a = t; a < r; a += 4) {\n      const t = e[a] * (1 / 255),\n            r = e[a + 1] * (1 / 255),\n            s = e[a + 2] * (1 / 255),\n            f = e[a + 3] * (1 / 255);\n      o[0] += t, o[1] += r, o[2] += s, o[3] += f, i[0] += t * t, i[1] += t * r, i[2] += t * s, i[3] += t * f, i[5] += r * r, i[6] += r * s, i[7] += r * f, i[10] += s * s, i[11] += s * f, i[15] += f * f;\n    }\n\n    return i[4] = i[1], i[8] = i[2], i[9] = i[6], i[12] = i[3], i[13] = i[7], i[14] = i[11], {\n      R: i,\n      m: o,\n      N: a\n    };\n  }\n\n  function estats(e) {\n    const {\n      R: t\n    } = e,\n          {\n      m: r\n    } = e,\n          {\n      N: i\n    } = e,\n          a = r[0],\n          s = r[1],\n          f = r[2],\n          l = r[3],\n          c = 0 == i ? 0 : 1 / i,\n          u = [t[0] - a * a * c, t[1] - a * s * c, t[2] - a * f * c, t[3] - a * l * c, t[4] - s * a * c, t[5] - s * s * c, t[6] - s * f * c, t[7] - s * l * c, t[8] - f * a * c, t[9] - f * s * c, t[10] - f * f * c, t[11] - f * l * c, t[12] - l * a * c, t[13] - l * s * c, t[14] - l * f * c, t[15] - l * l * c],\n          h = u,\n          d = o;\n    let A = [Math.random(), Math.random(), Math.random(), Math.random()],\n        g = 0,\n        p = 0;\n    if (0 != i) for (let e = 0; e < 16 && (A = d.multVec(h, A), p = Math.sqrt(d.dot(A, A)), A = d.sml(1 / p, A), !(0 != e && Math.abs(p - g) < 1e-9)); e++) g = p;\n    const m = [a * c, s * c, f * c, l * c];\n    return {\n      Cov: u,\n      q: m,\n      e: A,\n      L: g,\n      eMq255: d.dot(d.sml(255, m), A),\n      eMq: d.dot(A, m),\n      rgba: (Math.round(255 * m[3]) << 24 | Math.round(255 * m[2]) << 16 | Math.round(255 * m[1]) << 8 | Math.round(255 * m[0]) << 0) >>> 0\n    };\n  }\n\n  var o = {\n    multVec: (e, t) => [e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3], e[4] * t[0] + e[5] * t[1] + e[6] * t[2] + e[7] * t[3], e[8] * t[0] + e[9] * t[1] + e[10] * t[2] + e[11] * t[3], e[12] * t[0] + e[13] * t[1] + e[14] * t[2] + e[15] * t[3]],\n    dot: (e, t) => e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3],\n    sml: (e, t) => [e * t[0], e * t[1], e * t[2], e * t[3]]\n  };\n  UPNG.encode = function encode(e, t, r, i, o, a, s) {\n    null == i && (i = 0), null == s && (s = !1);\n    const f = compress(e, t, r, i, [!1, !1, !1, 0, s, !1]);\n    return compressPNG(f, -1), _main(f, t, r, o, a);\n  }, UPNG.encodeLL = function encodeLL(e, t, r, i, o, a, s, f) {\n    const l = {\n      ctype: 0 + (1 == i ? 0 : 2) + (0 == o ? 0 : 4),\n      depth: a,\n      frames: []\n    },\n          c = (i + o) * a,\n          u = c * t;\n\n    for (let i = 0; i < e.length; i++) l.frames.push({\n      rect: {\n        x: 0,\n        y: 0,\n        width: t,\n        height: r\n      },\n      img: new Uint8Array(e[i]),\n      blend: 0,\n      dispose: 1,\n      bpp: Math.ceil(c / 8),\n      bpl: Math.ceil(u / 8)\n    });\n\n    return compressPNG(l, 0, !0), _main(l, t, r, s, f);\n  }, UPNG.encode.compress = compress, UPNG.encode.dither = dither, UPNG.quantize = quantize, UPNG.quantize.getKDtree = getKDtree, UPNG.quantize.getNearest = getNearest;\n}();\nconst r = {\n  toArrayBuffer(e, t) {\n    const i = e.width,\n          o = e.height,\n          a = i << 2,\n          s = e.getContext(\"2d\").getImageData(0, 0, i, o),\n          f = new Uint32Array(s.data.buffer),\n          l = (32 * i + 31) / 32 << 2,\n          c = l * o,\n          u = 122 + c,\n          h = new ArrayBuffer(u),\n          d = new DataView(h),\n          A = 1 << 20;\n    let g,\n        p,\n        m,\n        w,\n        v = A,\n        b = 0,\n        y = 0,\n        E = 0;\n\n    function set16(e) {\n      d.setUint16(y, e, !0), y += 2;\n    }\n\n    function set32(e) {\n      d.setUint32(y, e, !0), y += 4;\n    }\n\n    function seek(e) {\n      y += e;\n    }\n\n    set16(19778), set32(u), seek(4), set32(122), set32(108), set32(i), set32(-o >>> 0), set16(1), set16(32), set32(3), set32(c), set32(2835), set32(2835), seek(8), set32(16711680), set32(65280), set32(255), set32(4278190080), set32(1466527264), function convert() {\n      for (; b < o && v > 0;) {\n        for (w = 122 + b * l, g = 0; g < a;) v--, p = f[E++], m = p >>> 24, d.setUint32(w + g, p << 8 | m), g += 4;\n\n        b++;\n      }\n\n      E < f.length ? (v = A, setTimeout(convert, r._dly)) : t(h);\n    }();\n  },\n\n  toBlob(e, t) {\n    this.toArrayBuffer(e, e => {\n      t(new Blob([e], {\n        type: \"image/bmp\"\n      }));\n    });\n  },\n\n  _dly: 9\n};\nvar i = {\n  CHROME: \"CHROME\",\n  FIREFOX: \"FIREFOX\",\n  DESKTOP_SAFARI: \"DESKTOP_SAFARI\",\n  IE: \"IE\",\n  IOS: \"IOS\",\n  ETC: \"ETC\"\n},\n    o = {\n  [i.CHROME]: 16384,\n  [i.FIREFOX]: 11180,\n  [i.DESKTOP_SAFARI]: 16384,\n  [i.IE]: 8192,\n  [i.IOS]: 4096,\n  [i.ETC]: 8192\n};\n\nconst a = \"undefined\" != typeof window,\n      s = \"undefined\" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope,\n      f = a && window.cordova && window.cordova.require && window.cordova.require(\"cordova/modulemapper\"),\n      CustomFile = (a || s) && (f && f.getOriginalSymbol(window, \"File\") || \"undefined\" != typeof File && File),\n      CustomFileReader = (a || s) && (f && f.getOriginalSymbol(window, \"FileReader\") || \"undefined\" != typeof FileReader && FileReader);\n\nfunction getFilefromDataUrl(e, t) {\n  let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Date.now();\n  return new Promise(i => {\n    const o = e.split(\",\"),\n          a = o[0].match(/:(.*?);/)[1],\n          s = globalThis.atob(o[1]);\n    let f = s.length;\n    const l = new Uint8Array(f);\n\n    for (; f--;) l[f] = s.charCodeAt(f);\n\n    const c = new Blob([l], {\n      type: a\n    });\n    c.name = t, c.lastModified = r, i(c);\n  });\n}\n\nfunction getDataUrlFromFile(e) {\n  return new Promise((t, r) => {\n    const i = new CustomFileReader();\n    i.onload = () => t(i.result), i.onerror = e => r(e), i.readAsDataURL(e);\n  });\n}\n\nfunction loadImage(e) {\n  return new Promise((t, r) => {\n    const i = new Image();\n    i.onload = () => t(i), i.onerror = e => r(e), i.src = e;\n  });\n}\n\nfunction getBrowserName() {\n  if (void 0 !== getBrowserName.cachedResult) return getBrowserName.cachedResult;\n  let e = i.ETC;\n  const {\n    userAgent: t\n  } = navigator;\n  return /Chrom(e|ium)/i.test(t) ? e = i.CHROME : /iP(ad|od|hone)/i.test(t) && /WebKit/i.test(t) ? e = i.IOS : /Safari/i.test(t) ? e = i.DESKTOP_SAFARI : /Firefox/i.test(t) ? e = i.FIREFOX : (/MSIE/i.test(t) || !0 == !!document.documentMode) && (e = i.IE), getBrowserName.cachedResult = e, getBrowserName.cachedResult;\n}\n\nfunction approximateBelowMaximumCanvasSizeOfBrowser(e, t) {\n  const r = getBrowserName(),\n        i = o[r];\n  let a = e,\n      s = t,\n      f = a * s;\n  const l = a > s ? s / a : a / s;\n\n  for (; f > i * i;) {\n    const e = (i + a) / 2,\n          t = (i + s) / 2;\n    e < t ? (s = t, a = t * l) : (s = e * l, a = e), f = a * s;\n  }\n\n  return {\n    width: a,\n    height: s\n  };\n}\n\nfunction getNewCanvasAndCtx(e, t) {\n  let r, i;\n\n  try {\n    if (r = new OffscreenCanvas(e, t), i = r.getContext(\"2d\"), null === i) throw new Error(\"getContext of OffscreenCanvas returns null\");\n  } catch (e) {\n    r = document.createElement(\"canvas\"), i = r.getContext(\"2d\");\n  }\n\n  return r.width = e, r.height = t, [r, i];\n}\n\nfunction drawImageInCanvas(e, t) {\n  const {\n    width: r,\n    height: i\n  } = approximateBelowMaximumCanvasSizeOfBrowser(e.width, e.height),\n        [o, a] = getNewCanvasAndCtx(r, i);\n  return t && /jpe?g/.test(t) && (a.fillStyle = \"white\", a.fillRect(0, 0, o.width, o.height)), a.drawImage(e, 0, 0, o.width, o.height), o;\n}\n\nfunction isIOS() {\n  return void 0 !== isIOS.cachedResult || (isIOS.cachedResult = [\"iPad Simulator\", \"iPhone Simulator\", \"iPod Simulator\", \"iPad\", \"iPhone\", \"iPod\"].includes(navigator.platform) || navigator.userAgent.includes(\"Mac\") && \"undefined\" != typeof document && \"ontouchend\" in document), isIOS.cachedResult;\n}\n\nfunction drawFileInCanvas(e) {\n  let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new Promise(function (r, o) {\n    let a, s;\n\n    var $Try_2_Post = function () {\n      try {\n        return s = drawImageInCanvas(a, t.fileType || e.type), r([a, s]);\n      } catch (e) {\n        return o(e);\n      }\n    },\n        $Try_2_Catch = function (t) {\n      try {\n        0;\n\n        var $Try_3_Catch = function (e) {\n          try {\n            throw e;\n          } catch (e) {\n            return o(e);\n          }\n        };\n\n        try {\n          let t;\n          return getDataUrlFromFile(e).then(function (e) {\n            try {\n              return t = e, loadImage(t).then(function (e) {\n                try {\n                  return a = e, function () {\n                    try {\n                      return $Try_2_Post();\n                    } catch (e) {\n                      return o(e);\n                    }\n                  }();\n                } catch (e) {\n                  return $Try_3_Catch(e);\n                }\n              }, $Try_3_Catch);\n            } catch (e) {\n              return $Try_3_Catch(e);\n            }\n          }, $Try_3_Catch);\n        } catch (e) {\n          $Try_3_Catch(e);\n        }\n      } catch (e) {\n        return o(e);\n      }\n    };\n\n    try {\n      if (isIOS() || [i.DESKTOP_SAFARI, i.MOBILE_SAFARI].includes(getBrowserName())) throw new Error(\"Skip createImageBitmap on IOS and Safari\");\n      return createImageBitmap(e).then(function (e) {\n        try {\n          return a = e, $Try_2_Post();\n        } catch (e) {\n          return $Try_2_Catch();\n        }\n      }, $Try_2_Catch);\n    } catch (e) {\n      $Try_2_Catch();\n    }\n  });\n}\n\nfunction canvasToFile(e, t, i, o) {\n  let a = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  return new Promise(function (s, f) {\n    let l;\n\n    if (\"image/png\" === t) {\n      let c, u, h;\n      return c = e.getContext(\"2d\"), ({\n        data: u\n      } = c.getImageData(0, 0, e.width, e.height)), h = UPNG.encode([u.buffer], e.width, e.height, 4096 * a), l = new Blob([h], {\n        type: t\n      }), l.name = i, l.lastModified = o, $If_4.call(this);\n    }\n\n    {\n      if (\"image/bmp\" === t) return new Promise(t => r.toBlob(e, t)).then(function (e) {\n        try {\n          return l = e, l.name = i, l.lastModified = o, $If_5.call(this);\n        } catch (e) {\n          return f(e);\n        }\n      }.bind(this), f);\n      {\n        if (\"function\" == typeof OffscreenCanvas && e instanceof OffscreenCanvas) return e.convertToBlob({\n          type: t,\n          quality: a\n        }).then(function (e) {\n          try {\n            return l = e, l.name = i, l.lastModified = o, $If_6.call(this);\n          } catch (e) {\n            return f(e);\n          }\n        }.bind(this), f);\n        {\n          let d;\n          return d = e.toDataURL(t, a), getFilefromDataUrl(d, i, o).then(function (e) {\n            try {\n              return l = e, $If_6.call(this);\n            } catch (e) {\n              return f(e);\n            }\n          }.bind(this), f);\n        }\n\n        function $If_6() {\n          return $If_5.call(this);\n        }\n      }\n\n      function $If_5() {\n        return $If_4.call(this);\n      }\n    }\n\n    function $If_4() {\n      return s(l);\n    }\n  });\n}\n\nfunction cleanupCanvasMemory(e) {\n  e.width = 0, e.height = 0;\n}\n\nfunction isAutoOrientationInBrowser() {\n  return new Promise(function (e, t) {\n    let r, i, o, a, s;\n    return void 0 !== isAutoOrientationInBrowser.cachedResult ? e(isAutoOrientationInBrowser.cachedResult) : (r = \"data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/xABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==\", getFilefromDataUrl(\"data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAAAAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/xABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==\", \"test.jpg\", Date.now()).then(function (r) {\n      try {\n        return i = r, drawFileInCanvas(i).then(function (r) {\n          try {\n            return o = r[1], canvasToFile(o, i.type, i.name, i.lastModified).then(function (r) {\n              try {\n                return a = r, cleanupCanvasMemory(o), drawFileInCanvas(a).then(function (r) {\n                  try {\n                    return s = r[0], isAutoOrientationInBrowser.cachedResult = 1 === s.width && 2 === s.height, e(isAutoOrientationInBrowser.cachedResult);\n                  } catch (e) {\n                    return t(e);\n                  }\n                }, t);\n              } catch (e) {\n                return t(e);\n              }\n            }, t);\n          } catch (e) {\n            return t(e);\n          }\n        }, t);\n      } catch (e) {\n        return t(e);\n      }\n    }, t));\n  });\n}\n\nfunction getExifOrientation(e) {\n  return new Promise((t, r) => {\n    const i = new CustomFileReader();\n    i.onload = e => {\n      const r = new DataView(e.target.result);\n      if (65496 != r.getUint16(0, !1)) return t(-2);\n      const i = r.byteLength;\n      let o = 2;\n\n      for (; o < i;) {\n        if (r.getUint16(o + 2, !1) <= 8) return t(-1);\n        const e = r.getUint16(o, !1);\n\n        if (o += 2, 65505 == e) {\n          if (1165519206 != r.getUint32(o += 2, !1)) return t(-1);\n          const e = 18761 == r.getUint16(o += 6, !1);\n          o += r.getUint32(o + 4, e);\n          const i = r.getUint16(o, e);\n          o += 2;\n\n          for (let a = 0; a < i; a++) if (274 == r.getUint16(o + 12 * a, e)) return t(r.getUint16(o + 12 * a + 8, e));\n        } else {\n          if (65280 != (65280 & e)) break;\n          o += r.getUint16(o, !1);\n        }\n      }\n\n      return t(-1);\n    }, i.onerror = e => r(e), i.readAsArrayBuffer(e);\n  });\n}\n\nfunction handleMaxWidthOrHeight(e, t) {\n  const {\n    width: r\n  } = e,\n        {\n    height: i\n  } = e,\n        {\n    maxWidthOrHeight: o\n  } = t;\n  let a,\n      s = e;\n  return isFinite(o) && (r > o || i > o) && ([s, a] = getNewCanvasAndCtx(r, i), r > i ? (s.width = o, s.height = i / r * o) : (s.width = r / i * o, s.height = o), a.drawImage(e, 0, 0, s.width, s.height), cleanupCanvasMemory(e)), s;\n}\n\nfunction followExifOrientation(e, t) {\n  const {\n    width: r\n  } = e,\n        {\n    height: i\n  } = e,\n        [o, a] = getNewCanvasAndCtx(r, i);\n\n  switch (t > 4 && t < 9 ? (o.width = i, o.height = r) : (o.width = r, o.height = i), t) {\n    case 2:\n      a.transform(-1, 0, 0, 1, r, 0);\n      break;\n\n    case 3:\n      a.transform(-1, 0, 0, -1, r, i);\n      break;\n\n    case 4:\n      a.transform(1, 0, 0, -1, 0, i);\n      break;\n\n    case 5:\n      a.transform(0, 1, 1, 0, 0, 0);\n      break;\n\n    case 6:\n      a.transform(0, 1, -1, 0, i, 0);\n      break;\n\n    case 7:\n      a.transform(0, -1, -1, 0, i, r);\n      break;\n\n    case 8:\n      a.transform(0, -1, 1, 0, 0, r);\n  }\n\n  return a.drawImage(e, 0, 0, r, i), cleanupCanvasMemory(e), o;\n}\n\nfunction compress(e, t) {\n  let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return new Promise(function (i, o) {\n    let a, s, f, l, c, u, h, d, A, g, p, m, w, v, b, y, E, F, _, B;\n\n    function incProgress() {\n      let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n      if (t.signal && t.signal.aborted) throw t.signal.reason;\n      a += e, t.onProgress(Math.min(a, 100));\n    }\n\n    function setProgress(e) {\n      if (t.signal && t.signal.aborted) throw t.signal.reason;\n      a = Math.min(Math.max(e, a), 100), t.onProgress(a);\n    }\n\n    return a = r, s = t.maxIteration || 10, f = 1024 * t.maxSizeMB * 1024, incProgress(), drawFileInCanvas(e, t).then(function (r) {\n      try {\n        return [, l] = r, incProgress(), c = handleMaxWidthOrHeight(l, t), incProgress(), new Promise(function (r, i) {\n          var o;\n          if (!(o = t.exifOrientation)) return getExifOrientation(e).then(function (e) {\n            try {\n              return o = e, $If_2.call(this);\n            } catch (e) {\n              return i(e);\n            }\n          }.bind(this), i);\n\n          function $If_2() {\n            return r(o);\n          }\n\n          return $If_2.call(this);\n        }).then(function (r) {\n          try {\n            return u = r, incProgress(), isAutoOrientationInBrowser().then(function (r) {\n              try {\n                return h = r ? c : followExifOrientation(c, u), incProgress(), d = t.initialQuality || 1, A = t.fileType || e.type, canvasToFile(h, A, e.name, e.lastModified, d).then(function (r) {\n                  try {\n                    {\n                      if (g = r, incProgress(), p = g.size > f, m = g.size > e.size, !p && !m) return setProgress(100), i(g);\n                      var a;\n\n                      function $Loop_3() {\n                        if (s-- && (b > f || b > w)) {\n                          let t, r;\n                          return t = B ? .95 * _.width : _.width, r = B ? .95 * _.height : _.height, [E, F] = getNewCanvasAndCtx(t, r), F.drawImage(_, 0, 0, t, r), d *= \"image/png\" === A ? .85 : .95, canvasToFile(E, A, e.name, e.lastModified, d).then(function (e) {\n                            try {\n                              return y = e, cleanupCanvasMemory(_), _ = E, b = y.size, setProgress(Math.min(99, Math.floor((v - b) / (v - f) * 100))), $Loop_3;\n                            } catch (e) {\n                              return o(e);\n                            }\n                          }, o);\n                        }\n\n                        return [1];\n                      }\n\n                      return w = e.size, v = g.size, b = v, _ = h, B = !t.alwaysKeepResolution && p, (a = function (e) {\n                        for (; e;) {\n                          if (e.then) return void e.then(a, o);\n\n                          try {\n                            if (e.pop) {\n                              if (e.length) return e.pop() ? $Loop_3_exit.call(this) : e;\n                              e = $Loop_3;\n                            } else e = e.call(this);\n                          } catch (e) {\n                            return o(e);\n                          }\n                        }\n                      }.bind(this))($Loop_3);\n\n                      function $Loop_3_exit() {\n                        return cleanupCanvasMemory(_), cleanupCanvasMemory(E), cleanupCanvasMemory(c), cleanupCanvasMemory(h), cleanupCanvasMemory(l), setProgress(100), i(y);\n                      }\n                    }\n                  } catch (u) {\n                    return o(u);\n                  }\n                }.bind(this), o);\n              } catch (e) {\n                return o(e);\n              }\n            }.bind(this), o);\n          } catch (e) {\n            return o(e);\n          }\n        }.bind(this), o);\n      } catch (e) {\n        return o(e);\n      }\n    }.bind(this), o);\n  });\n}\n\nconst l = \"\\nlet scriptImported = false\\nself.addEventListener('message', async (e) => {\\n  const { file, id, imageCompressionLibUrl, options } = e.data\\n  options.onProgress = (progress) => self.postMessage({ progress, id })\\n  try {\\n    if (!scriptImported) {\\n      // console.log('[worker] importScripts', imageCompressionLibUrl)\\n      self.importScripts(imageCompressionLibUrl)\\n      scriptImported = true\\n    }\\n    // console.log('[worker] self', self)\\n    const compressedFile = await imageCompression(file, options)\\n    self.postMessage({ file: compressedFile, id })\\n  } catch (e) {\\n    // console.error('[worker] error', e)\\n    self.postMessage({ error: e.message + '\\\\n' + e.stack, id })\\n  }\\n})\\n\";\nlet c;\n\nfunction compressOnWebWorker(e, t) {\n  return new Promise((r, i) => {\n    c || (c = function createWorkerScriptURL(e) {\n      const t = [];\n      return \"function\" == typeof e ? t.push(`(${e})()`) : t.push(e), URL.createObjectURL(new Blob(t));\n    }(l));\n    const o = new Worker(c);\n    o.addEventListener(\"message\", function handler(e) {\n      if (t.signal && t.signal.aborted) o.terminate();else if (void 0 === e.data.progress) {\n        if (e.data.error) return i(new Error(e.data.error)), void o.terminate();\n        r(e.data.file), o.terminate();\n      } else t.onProgress(e.data.progress);\n    }), o.addEventListener(\"error\", i), t.signal && t.signal.addEventListener(\"abort\", () => {\n      i(t.signal.reason), o.terminate();\n    }), o.postMessage({\n      file: e,\n      imageCompressionLibUrl: t.libURL,\n      options: { ...t,\n        onProgress: void 0,\n        signal: void 0\n      }\n    });\n  });\n}\n\nfunction imageCompression(e, t) {\n  return new Promise(function (r, i) {\n    let o, a, s, f, l, c;\n    if (o = { ...t\n    }, s = 0, ({\n      onProgress: f\n    } = o), o.maxSizeMB = o.maxSizeMB || Number.POSITIVE_INFINITY, l = \"boolean\" != typeof o.useWebWorker || o.useWebWorker, delete o.useWebWorker, o.onProgress = e => {\n      s = e, \"function\" == typeof f && f(s);\n    }, !(e instanceof Blob || e instanceof CustomFile)) return i(new Error(\"The file given is not an instance of Blob or File\"));\n    if (!/^image/.test(e.type)) return i(new Error(\"The file given is not an image\"));\n    if (c = \"undefined\" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope, !l || \"function\" != typeof Worker || c) return compress(e, o).then(function (e) {\n      try {\n        return a = e, $If_4.call(this);\n      } catch (e) {\n        return i(e);\n      }\n    }.bind(this), i);\n\n    var u = function () {\n      try {\n        return $If_4.call(this);\n      } catch (e) {\n        return i(e);\n      }\n    }.bind(this),\n        $Try_1_Catch = function (t) {\n      try {\n        return compress(e, o).then(function (e) {\n          try {\n            return a = e, u();\n          } catch (e) {\n            return i(e);\n          }\n        }, i);\n      } catch (e) {\n        return i(e);\n      }\n    };\n\n    try {\n      return o.libURL = o.libURL || \"https://cdn.jsdelivr.net/npm/browser-image-compression@2.0.2/dist/browser-image-compression.js\", compressOnWebWorker(e, o).then(function (e) {\n        try {\n          return a = e, u();\n        } catch (e) {\n          return $Try_1_Catch();\n        }\n      }, $Try_1_Catch);\n    } catch (e) {\n      $Try_1_Catch();\n    }\n\n    function $If_4() {\n      try {\n        a.name = e.name, a.lastModified = e.lastModified;\n      } catch (e) {}\n\n      try {\n        o.preserveExif && \"image/jpeg\" === e.type && (!o.fileType || o.fileType && o.fileType === e.type) && (a = copyExifWithoutOrientation(e, a));\n      } catch (e) {}\n\n      return r(a);\n    }\n  });\n}\n\nimageCompression.getDataUrlFromFile = getDataUrlFromFile, imageCompression.getFilefromDataUrl = getFilefromDataUrl, imageCompression.loadImage = loadImage, imageCompression.drawImageInCanvas = drawImageInCanvas, imageCompression.drawFileInCanvas = drawFileInCanvas, imageCompression.canvasToFile = canvasToFile, imageCompression.getExifOrientation = getExifOrientation, imageCompression.handleMaxWidthOrHeight = handleMaxWidthOrHeight, imageCompression.followExifOrientation = followExifOrientation, imageCompression.cleanupCanvasMemory = cleanupCanvasMemory, imageCompression.isAutoOrientationInBrowser = isAutoOrientationInBrowser, imageCompression.approximateBelowMaximumCanvasSizeOfBrowser = approximateBelowMaximumCanvasSizeOfBrowser, imageCompression.copyExifWithoutOrientation = copyExifWithoutOrientation, imageCompression.getBrowserName = getBrowserName, imageCompression.version = \"2.0.2\";\nexport { imageCompression as default };","map":{"version":3,"mappings":"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","names":["copyExifWithoutOrientation","srcBlob","destBlob","$error","type","i","getApp1Segment","blob","reader","addEventListener","target","result","view","offset","getUint16","marker","littleEndian","tiffOffset","endOfTagsOffset","ifd0Offset","e","Blob","readAsArrayBuffer","module","UZIP","u16","u32","t","exports","rUs","data","eocd","rUi","o","cnu","cnt","csize","coffs","sign","usize","nl","el","cl","roff","out","onlyNames","cmpr","time","crc32","nlen","elen","name","size","file","inflateRaw","buf","inflate","opts","Uint8Array","Math","floor","off","r","F","crc","adler","length","level","tot","wUs","obj","cpr","p","zpd","fof","_writeHeader","ioff","push","wUi","fn","ext","toLowerCase","indexOf","f","table","Uint32Array","n","k","c","tab","update","b","l","len","a","end","readUshort","writeUshort","buff","readUint","writeUint","readASCII","s","writeASCII","readUTF8","ns","toString","str","ci","code","deflateRaw","opt","lvl","U","goodIndex","_goodIndex","hash","putsE","pos","cvrd","dlen","strt","y","prev","nc","ii","lits","ebits","bs","mch","dst","li","lc","_bestMatch","dif","pi","dlim","tl","nice","maxd","j","ei","curd","m","td","_howLong","_hash","T","ML","putsF","dset","cstSize","fxdSize","dynSize","BFINAL","_copyExact","ltree","fltree","dtree","makeCodes","revCodes","MD","MH","_codeTiny","lset","itree","si","qb","lgi","dgi","p8","set","getTrees","numl","numd","ihst","_hufTree","numh","getSecond","nonZero","hst","tree","nxt","nnxt","lz","zc","list","lit","l2","i1","d","i0","i2","maxl","setDepth","bCost","dbt","sort","dps","od","console","v","arr","_writeLit","bitsF","bitsE","decodeTiny","codes2map","get17","noBuf","lmap","dmap","BTYPE","HDIST","HCLEN","fdmap","HLIT","imap","_copyOut","ebs","ldef","dlit","dcode","O","P","_check","bl","nbuf","_decodeTiny","LL","ll","src","mx","bits","bl_count","next_code","r15","val","rest","MAX_BITS","dt","_get17","_get25","Uint16Array","ordr","of0","exb","df0","dxb","ddef","flmap","fdtree","ttree","rev15","lhst","dhst","x","tgt","sv","pushV","__proto__","default","nextZero","readBytes","pad","decodeURIComponent","w","h","bpl","ceil","bf","bf32","buffer","ctype","depth","rs","area","tabs","tRNS","A","ti","tg","tb","qi","PLTE","ap","s0","t0","cj","gr","di","tr","to","al","dd","_filterZero","bpp","img","starting_col","col_increment","pass","sh","cr","cc","sw","starting_row","col","cdi","row","cbpp","ri","_readInterlace","H","N","W","C","J","Q","X","u","Z","R","K","M","S","I","g","z","_","q","D","V","$","Y","_getBPP","pa","pb","_bin","tw","th","xoff","yoff","mode","sb","fr","fg","fb","fa","ba","br","bg","bb","oa","ioa","ifa","decode","frames","fd","foff","mgck","_IHDR","bin","slice","res","doff","num_frames","num_plays","_decompress","width","height","del","rect","delay","round","dispose","blend","keyw","nz","_inflate","text","bfr","interlace","toRGBA8","empty","frm","fy","fw","fdata","_copyTile","_paeth","UPNG","paeth","crcLib","er","dg","db","da","dr","plte","MTD","nplt","pc","ce","ni","cd","nd","addErr","err","tb32","nimg","wAs","anim","cicc","pltAlpha","leng","iCCP","pako","dl","wr","sl","pHYs","loop","fi","dels","imgd","filter","levelZero","nh","prms","evenCrd","forbidPrev","minBits","forbidPlte","dith","alphaAnd","bufs","ilen","alwaysBlend","cimg32","cimg","nw","it","tlim","miy","max","may","p32","mix","sarea","tarea","tstp","nx","ny","_prepareDiff","r1","frms","miX","miY","_updateFrame","framize","onlyBlend","ps","tlen","byteLength","il","nbufs","qres","quantize","abuf","bln","ind","cof","inds","img32","cmc","cmap","inj","gotAlpha","pimg","pimg32","cx","cy","rec","ftry","CMPR","deflate","tsize","fls","getKDtree","root","KD","getNearest","left","right","bst","est","tdst","leafs","maxL","mi","node","splitPixels","L","ln","stats","estats","rn","dist","d1","d2","pd","node0","node1","planeDst","nimg32","eMq","vecDot","m1","m2","m3","Rj","m0","iN","M4","tmi","Cov","eMq255","sml","rgba","multVec","dot","compressPNG","_main","ac","bipp","compress","dither","toArrayBuffer","canvas","callback","w4","idata","data32","stride","pixelArraySize","fileLength","blockSize","set16","set32","seek","block","setTimeout","_dly","toBlob","BROWSER_NAME","CHROME","FIREFOX","DESKTOP_SAFARI","IE","IOS","ETC","MAX_CANVAS_SIZE","isBrowser","window","inWebWorker","self","WorkerGlobalScope","moduleMapper","require","CustomFile","CustomFileReader","FileReader","Promise","resolve","dataUrl","mime","bstr","u8arr","lastModified","reject","onload","loadImage","onerror","getBrowserName","userAgent","test","browserName","cachedResult","maximumCanvasSize","halfSizeWidth","halfSizeHeight","ratio","ctx","isIOS","includes","navigator","platform","document","$Try_3_Catch","createImageBitmap","$Try_2_Catch","fileType","quality","then","fileLastModified","fileName","$await_12","cleanupCanvasMemory","DataView","little","tags","options","maxWidthOrHeight","isFinite","newCanvas","getNewCanvasAndCtx","exifOrientation","aborted","progress","incProgress","drawFileInCanvas","origCanvas","getExifOrientation","$await_6","isAutoOrientationInBrowser","maxWidthOrHeightFixedCanvas","$await_8","followExifOrientation","orientationFixedCanvas","outputFileType","origExceedMaxSize","maxSizeByte","setProgress","tempFile","currentSize","sourceSize","newWidth","shouldReduceResolution","bind","workerScript","workerScriptURL","createWorkerScriptURL","script","blobArgs","URL","worker","onProgress","POSITIVE_INFINITY","useWebWorker","Error","compressedFile","$await_7","$await_5","$Try_1_Catch","imageCompression","getDataUrlFromFile","getFilefromDataUrl","drawImageInCanvas","canvasToFile","handleMaxWidthOrHeight"],"sources":["C:\\Users\\HP\\Desktop\\coding-files\\projects\\web-chat-app\\client\\node_modules\\browser-image-compression\\lib\\copyExifWithoutOrientation.js","C:\\Users\\HP\\Desktop\\coding-files\\projects\\web-chat-app\\client\\node_modules\\browser-image-compression\\node_modules\\uzip\\UZIP.js","C:\\Users\\HP\\Desktop\\coding-files\\projects\\web-chat-app\\client\\node_modules\\browser-image-compression\\lib\\UPNG.js","C:\\Users\\HP\\Desktop\\coding-files\\projects\\web-chat-app\\client\\node_modules\\browser-image-compression\\lib\\canvastobmp.js","C:\\Users\\HP\\Desktop\\coding-files\\projects\\web-chat-app\\client\\node_modules\\browser-image-compression\\lib\\config\\browser-name.js","C:\\Users\\HP\\Desktop\\coding-files\\projects\\web-chat-app\\client\\node_modules\\browser-image-compression\\lib\\config\\max-canvas-size.js","C:\\Users\\HP\\Desktop\\coding-files\\projects\\web-chat-app\\client\\node_modules\\browser-image-compression\\lib\\utils.js","C:\\Users\\HP\\Desktop\\coding-files\\projects\\web-chat-app\\client\\node_modules\\browser-image-compression\\lib\\image-compression.js","C:\\Users\\HP\\Desktop\\coding-files\\projects\\web-chat-app\\client\\node_modules\\browser-image-compression\\lib\\web-worker.js","C:\\Users\\HP\\Desktop\\coding-files\\projects\\web-chat-app\\client\\node_modules\\browser-image-compression\\lib\\index.js"],"sourcesContent":["// https://gist.github.com/tonytonyjan/ffb7cd0e82cb293b843ece7e79364233\n// Copyright (c) 2022 Weihang Jian <tonytonyjan@gmail.com>\n\nexport default async function copyExifWithoutOrientation(srcBlob, destBlob) {\n  const exif = await getApp1Segment(srcBlob);\n  return new Blob([destBlob.slice(0, 2), exif, destBlob.slice(2)], {\n    type: 'image/jpeg',\n  });\n}\n\nconst SOI = 0xffd8;\nconst SOS = 0xffda;\nconst APP1 = 0xffe1;\nconst EXIF = 0x45786966;\nconst LITTLE_ENDIAN = 0x4949;\nconst BIG_ENDIAN = 0x4d4d;\nconst TAG_ID_ORIENTATION = 0x0112;\nconst TAG_TYPE_SHORT = 3;\nconst getApp1Segment = (blob) => new Promise((resolve, reject) => {\n  const reader = new FileReader();\n  reader.addEventListener('load', ({ target: { result: buffer } }) => {\n    const view = new DataView(buffer);\n    let offset = 0;\n    if (view.getUint16(offset) !== SOI) return reject('not a valid JPEG');\n    offset += 2;\n\n    while (true) {\n      const marker = view.getUint16(offset);\n      if (marker === SOS) break;\n\n      const size = view.getUint16(offset + 2);\n      if (marker === APP1 && view.getUint32(offset + 4) === EXIF) {\n        const tiffOffset = offset + 10;\n        let littleEndian;\n        switch (view.getUint16(tiffOffset)) {\n          case LITTLE_ENDIAN:\n            littleEndian = true;\n            break;\n          case BIG_ENDIAN:\n            littleEndian = false;\n            break;\n          default:\n            return reject('TIFF header contains invalid endian');\n        }\n        if (view.getUint16(tiffOffset + 2, littleEndian) !== 0x2a) { return reject('TIFF header contains invalid version'); }\n\n        const ifd0Offset = view.getUint32(tiffOffset + 4, littleEndian);\n        const endOfTagsOffset = tiffOffset\n              + ifd0Offset\n              + 2\n              + view.getUint16(tiffOffset + ifd0Offset, littleEndian) * 12;\n        for (\n          let i = tiffOffset + ifd0Offset + 2;\n          i < endOfTagsOffset;\n          i += 12\n        ) {\n          const tagId = view.getUint16(i, littleEndian);\n          if (tagId == TAG_ID_ORIENTATION) {\n            if (view.getUint16(i + 2, littleEndian) !== TAG_TYPE_SHORT) { return reject('Orientation data type is invalid'); }\n\n            if (view.getUint32(i + 4, littleEndian) !== 1) { return reject('Orientation data count is invalid'); }\n\n            view.setUint16(i + 8, 1, littleEndian);\n            break;\n          }\n        }\n        return resolve(buffer.slice(offset, offset + 2 + size));\n      }\n      offset += 2 + size;\n    }\n    return resolve(new Blob());\n  });\n  reader.readAsArrayBuffer(blob);\n});\n","\r\n\r\nvar UZIP = {};\r\nif(typeof module == \"object\") module.exports = UZIP;\r\n\r\n\r\nUZIP[\"parse\"] = function(buf, onlyNames)\t// ArrayBuffer\r\n{\r\n\tvar rUs = UZIP.bin.readUshort, rUi = UZIP.bin.readUint, o = 0, out = {};\r\n\tvar data = new Uint8Array(buf);\r\n\tvar eocd = data.length-4;\r\n\t\r\n\twhile(rUi(data, eocd)!=0x06054b50) eocd--;\r\n\t\r\n\tvar o = eocd;\r\n\to+=4;\t// sign  = 0x06054b50\r\n\to+=4;  // disks = 0;\r\n\tvar cnu = rUs(data, o);  o+=2;\r\n\tvar cnt = rUs(data, o);  o+=2;\r\n\t\t\t\r\n\tvar csize = rUi(data, o);  o+=4;\r\n\tvar coffs = rUi(data, o);  o+=4;\r\n\t\r\n\to = coffs;\r\n\tfor(var i=0; i<cnu; i++)\r\n\t{\r\n\t\tvar sign = rUi(data, o);  o+=4;\r\n\t\to += 4;  // versions;\r\n\t\to += 4;  // flag + compr\r\n\t\to += 4;  // time\r\n\t\t\r\n\t\tvar crc32 = rUi(data, o);  o+=4;\r\n\t\tvar csize = rUi(data, o);  o+=4;\r\n\t\tvar usize = rUi(data, o);  o+=4;\r\n\t\t\r\n\t\tvar nl = rUs(data, o), el = rUs(data, o+2), cl = rUs(data, o+4);  o += 6;  // name, extra, comment\r\n\t\to += 8;  // disk, attribs\r\n\t\t\r\n\t\tvar roff = rUi(data, o);  o+=4;\r\n\t\to += nl + el + cl;\r\n\t\t\r\n\t\tUZIP._readLocal(data, roff, out, csize, usize, onlyNames);\r\n\t}\r\n\t//console.log(out);\r\n\treturn out;\r\n}\r\n\r\nUZIP._readLocal = function(data, o, out, csize, usize, onlyNames)\r\n{\r\n\tvar rUs = UZIP.bin.readUshort, rUi = UZIP.bin.readUint;\r\n\tvar sign  = rUi(data, o);  o+=4;\r\n\tvar ver   = rUs(data, o);  o+=2;\r\n\tvar gpflg = rUs(data, o);  o+=2;\r\n\t//if((gpflg&8)!=0) throw \"unknown sizes\";\r\n\tvar cmpr  = rUs(data, o);  o+=2;\r\n\t\r\n\tvar time  = rUi(data, o);  o+=4;\r\n\t\r\n\tvar crc32 = rUi(data, o);  o+=4;\r\n\t//var csize = rUi(data, o);  o+=4;\r\n\t//var usize = rUi(data, o);  o+=4;\r\n\to+=8;\r\n\t\t\r\n\tvar nlen  = rUs(data, o);  o+=2;\r\n\tvar elen  = rUs(data, o);  o+=2;\r\n\t\t\r\n\tvar name =  UZIP.bin.readUTF8(data, o, nlen);  o+=nlen;  //console.log(name);\r\n\to += elen;\r\n\t\t\t\r\n\t//console.log(sign.toString(16), ver, gpflg, cmpr, crc32.toString(16), \"csize, usize\", csize, usize, nlen, elen, name, o);\r\n\tif(onlyNames) {  out[name]={size:usize, csize:csize};  return;  }   \r\n\tvar file = new Uint8Array(data.buffer, o);\r\n\tif(false) {}\r\n\telse if(cmpr==0) out[name] = new Uint8Array(file.buffer.slice(o, o+csize));\r\n\telse if(cmpr==8) {\r\n\t\tvar buf = new Uint8Array(usize);  UZIP.inflateRaw(file, buf);\r\n\t\t/*var nbuf = pako[\"inflateRaw\"](file);\r\n\t\tif(usize>8514000) {\r\n\t\t\t//console.log(PUtils.readASCII(buf , 8514500, 500));\r\n\t\t\t//console.log(PUtils.readASCII(nbuf, 8514500, 500));\r\n\t\t}\r\n\t\tfor(var i=0; i<buf.length; i++) if(buf[i]!=nbuf[i]) {  console.log(buf.length, nbuf.length, usize, i);  throw \"e\";  }\r\n\t\t*/\r\n\t\tout[name] = buf;\r\n\t}\r\n\telse throw \"unknown compression method: \"+cmpr;\r\n}\r\n\r\nUZIP.inflateRaw = function(file, buf) {  return UZIP.F.inflate(file, buf);  }\r\nUZIP.inflate    = function(file, buf) { \r\n\tvar CMF = file[0], FLG = file[1];\r\n\tvar CM = (CMF&15), CINFO = (CMF>>>4);\r\n\t//console.log(CM, CINFO,CMF,FLG);\r\n\treturn UZIP.inflateRaw(new Uint8Array(file.buffer, file.byteOffset+2, file.length-6), buf);  \r\n}\r\nUZIP.deflate    = function(data, opts/*, buf, off*/) {\r\n\tif(opts==null) opts={level:6};\r\n\tvar off=0, buf=new Uint8Array(50+Math.floor(data.length*1.1));\r\n\tbuf[off]=120;  buf[off+1]=156;  off+=2;\r\n\toff = UZIP.F.deflateRaw(data, buf, off, opts.level);\r\n\tvar crc = UZIP.adler(data, 0, data.length);\r\n\tbuf[off+0]=((crc>>>24)&255); \r\n\tbuf[off+1]=((crc>>>16)&255); \r\n\tbuf[off+2]=((crc>>> 8)&255); \r\n\tbuf[off+3]=((crc>>> 0)&255); \t\r\n\treturn new Uint8Array(buf.buffer, 0, off+4);\r\n}\r\nUZIP.deflateRaw = function(data, opts) {\r\n\tif(opts==null) opts={level:6};\r\n\tvar buf=new Uint8Array(50+Math.floor(data.length*1.1));\r\n\tvar off = UZIP.F.deflateRaw(data, buf, off, opts.level);\r\n\treturn new Uint8Array(buf.buffer, 0, off);\r\n}\r\n\r\n\r\nUZIP.encode = function(obj, noCmpr) {\r\n\tif(noCmpr==null) noCmpr=false;\r\n\tvar tot = 0, wUi = UZIP.bin.writeUint, wUs = UZIP.bin.writeUshort;\r\n\tvar zpd = {};\r\n\tfor(var p in obj) {  var cpr = !UZIP._noNeed(p) && !noCmpr, buf = obj[p], crc = UZIP.crc.crc(buf,0,buf.length); \r\n\t\tzpd[p] = {  cpr:cpr, usize:buf.length, crc:crc, file: (cpr ? UZIP.deflateRaw(buf) : buf)  };  }\r\n\t\r\n\tfor(var p in zpd) tot += zpd[p].file.length + 30 + 46 + 2*UZIP.bin.sizeUTF8(p);\r\n\ttot +=  22;\r\n\t\r\n\tvar data = new Uint8Array(tot), o = 0;\r\n\tvar fof = []\r\n\t\r\n\tfor(var p in zpd) {\r\n\t\tvar file = zpd[p];  fof.push(o);\r\n\t\to = UZIP._writeHeader(data, o, p, file, 0);\r\n\t}\r\n\tvar i=0, ioff = o;\r\n\tfor(var p in zpd) {\r\n\t\tvar file = zpd[p];  fof.push(o);\r\n\t\to = UZIP._writeHeader(data, o, p, file, 1, fof[i++]);\t\t\r\n\t}\r\n\tvar csize = o-ioff;\r\n\t\r\n\twUi(data, o, 0x06054b50);  o+=4;\r\n\to += 4;  // disks\r\n\twUs(data, o, i);  o += 2;\r\n\twUs(data, o, i);  o += 2;\t// number of c d records\r\n\twUi(data, o, csize);  o += 4;\r\n\twUi(data, o, ioff );  o += 4;\r\n\to += 2;\r\n\treturn data.buffer;\r\n}\r\n// no need to compress .PNG, .ZIP, .JPEG ....\r\nUZIP._noNeed = function(fn) {  var ext = fn.split(\".\").pop().toLowerCase();  return \"png,jpg,jpeg,zip\".indexOf(ext)!=-1;  }\r\n\r\nUZIP._writeHeader = function(data, o, p, obj, t, roff)\r\n{\r\n\tvar wUi = UZIP.bin.writeUint, wUs = UZIP.bin.writeUshort;\r\n\tvar file = obj.file;\r\n\t\r\n\twUi(data, o, t==0 ? 0x04034b50 : 0x02014b50);  o+=4; // sign\r\n\tif(t==1) o+=2;  // ver made by\r\n\twUs(data, o, 20);  o+=2;\t// ver\r\n\twUs(data, o,  0);  o+=2;    // gflip\r\n\twUs(data, o,  obj.cpr?8:0);  o+=2;\t// cmpr\r\n\t\t\r\n\twUi(data, o,  0);  o+=4;\t// time\t\t\r\n\twUi(data, o, obj.crc);  o+=4;\t// crc32\r\n\twUi(data, o, file.length);  o+=4;\t// csize\r\n\twUi(data, o, obj.usize);  o+=4;\t// usize\r\n\t\t\r\n\twUs(data, o, UZIP.bin.sizeUTF8(p));  o+=2;\t// nlen\r\n\twUs(data, o, 0);  o+=2;\t// elen\r\n\t\r\n\tif(t==1) {\r\n\t\to += 2;  // comment length\r\n\t\to += 2;  // disk number\r\n\t\to += 6;  // attributes\r\n\t\twUi(data, o, roff);  o+=4;\t// usize\r\n\t}\r\n\tvar nlen = UZIP.bin.writeUTF8(data, o, p);  o+= nlen;\t\r\n\tif(t==0) {  data.set(file, o);  o += file.length;  }\r\n\treturn o;\r\n}\r\n\r\n\r\n\r\n\r\n\r\nUZIP.crc = {\r\n\ttable : ( function() {\r\n\t   var tab = new Uint32Array(256);\r\n\t   for (var n=0; n<256; n++) {\r\n\t\t\tvar c = n;\r\n\t\t\tfor (var k=0; k<8; k++) {\r\n\t\t\t\tif (c & 1)  c = 0xedb88320 ^ (c >>> 1);\r\n\t\t\t\telse        c = c >>> 1;\r\n\t\t\t}\r\n\t\t\ttab[n] = c;  }    \r\n\t\treturn tab;  })(),\r\n\tupdate : function(c, buf, off, len) {\r\n\t\tfor (var i=0; i<len; i++)  c = UZIP.crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);\r\n\t\treturn c;\r\n\t},\r\n\tcrc : function(b,o,l)  {  return UZIP.crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }\r\n}\r\nUZIP.adler = function(data,o,len) {\r\n\tvar a = 1, b = 0;\r\n\tvar off = o, end=o+len;\r\n\twhile(off<end) {\r\n\t\tvar eend = Math.min(off+5552, end);\r\n\t\twhile(off<eend) {\r\n\t\t\ta += data[off++];\r\n\t\t\tb += a;\r\n\t\t}\r\n\t\ta=a%65521;\r\n\t\tb=b%65521;\r\n\t}\r\n    return (b << 16) | a;\r\n}\r\n\r\nUZIP.bin = {\r\n\treadUshort : function(buff,p)  {  return (buff[p]) | (buff[p+1]<<8);  },\r\n\twriteUshort: function(buff,p,n){  buff[p] = (n)&255;  buff[p+1] = (n>>8)&255;  },\r\n\treadUint   : function(buff,p)  {  return (buff[p+3]*(256*256*256)) + ((buff[p+2]<<16) | (buff[p+1]<< 8) | buff[p]);  },\r\n\twriteUint  : function(buff,p,n){  buff[p]=n&255;  buff[p+1]=(n>>8)&255;  buff[p+2]=(n>>16)&255;  buff[p+3]=(n>>24)&255;  },\r\n\treadASCII  : function(buff,p,l){  var s = \"\";  for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);  return s;    },\r\n\twriteASCII : function(data,p,s){  for(var i=0; i<s.length; i++) data[p+i] = s.charCodeAt(i);  },\r\n\tpad : function(n) { return n.length < 2 ? \"0\" + n : n; },\r\n\treadUTF8 : function(buff, p, l) {\r\n\t\tvar s = \"\", ns;\r\n\t\tfor(var i=0; i<l; i++) s += \"%\" + UZIP.bin.pad(buff[p+i].toString(16));\r\n\t\ttry {  ns = decodeURIComponent(s); }\r\n\t\tcatch(e) {  return UZIP.bin.readASCII(buff, p, l);  }\r\n\t\treturn  ns;\r\n\t},\r\n\twriteUTF8 : function(buff, p, str) {\r\n\t\tvar strl = str.length, i=0;\r\n\t\tfor(var ci=0; ci<strl; ci++)\r\n\t\t{\r\n\t\t\tvar code = str.charCodeAt(ci);\r\n\t\t\tif     ((code&(0xffffffff-(1<< 7)+1))==0) {  buff[p+i] = (     code     );  i++;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<11)+1))==0) {  buff[p+i] = (192|(code>> 6));  buff[p+i+1] = (128|((code>> 0)&63));  i+=2;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<16)+1))==0) {  buff[p+i] = (224|(code>>12));  buff[p+i+1] = (128|((code>> 6)&63));  buff[p+i+2] = (128|((code>>0)&63));  i+=3;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<21)+1))==0) {  buff[p+i] = (240|(code>>18));  buff[p+i+1] = (128|((code>>12)&63));  buff[p+i+2] = (128|((code>>6)&63));  buff[p+i+3] = (128|((code>>0)&63)); i+=4;  }\r\n\t\t\telse throw \"e\";\r\n\t\t}\r\n\t\treturn i;\r\n\t},\r\n\tsizeUTF8 : function(str) {\r\n\t\tvar strl = str.length, i=0;\r\n\t\tfor(var ci=0; ci<strl; ci++)\r\n\t\t{\r\n\t\t\tvar code = str.charCodeAt(ci);\r\n\t\t\tif     ((code&(0xffffffff-(1<< 7)+1))==0) {  i++ ;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<11)+1))==0) {  i+=2;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<16)+1))==0) {  i+=3;  }\r\n\t\t\telse if((code&(0xffffffff-(1<<21)+1))==0) {  i+=4;  }\r\n\t\t\telse throw \"e\";\r\n\t\t}\r\n\t\treturn i;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\nUZIP.F = {};\r\n\r\nUZIP.F.deflateRaw = function(data, out, opos, lvl) {\t\r\n\tvar opts = [\r\n\t/*\r\n\t\t ush good_length; /* reduce lazy search above this match length \r\n\t\t ush max_lazy;    /* do not perform lazy search above this match length \r\n         ush nice_length; /* quit search above this match length \r\n\t*/\r\n\t/*      good lazy nice chain */\r\n\t/* 0 */ [ 0,   0,   0,    0,0],  /* store only */\r\n\t/* 1 */ [ 4,   4,   8,    4,0], /* max speed, no lazy matches */\r\n\t/* 2 */ [ 4,   5,  16,    8,0],\r\n\t/* 3 */ [ 4,   6,  16,   16,0],\r\n\r\n\t/* 4 */ [ 4,  10,  16,   32,0],  /* lazy matches */\r\n\t/* 5 */ [ 8,  16,  32,   32,0],\r\n\t/* 6 */ [ 8,  16, 128,  128,0],\r\n\t/* 7 */ [ 8,  32, 128,  256,0],\r\n\t/* 8 */ [32, 128, 258, 1024,1],\r\n\t/* 9 */ [32, 258, 258, 4096,1]]; /* max compression */\r\n\t\r\n\tvar opt = opts[lvl];\r\n\t\r\n\t\r\n\tvar U = UZIP.F.U, goodIndex = UZIP.F._goodIndex, hash = UZIP.F._hash, putsE = UZIP.F._putsE;\r\n\tvar i = 0, pos = opos<<3, cvrd = 0, dlen = data.length;\r\n\t\r\n\tif(lvl==0) {\r\n\t\twhile(i<dlen) {   var len = Math.min(0xffff, dlen-i);\r\n\t\t\tputsE(out, pos, (i+len==dlen ? 1 : 0));  pos = UZIP.F._copyExact(data, i, len, out, pos+8);  i += len;  }\r\n\t\treturn pos>>>3;\r\n\t}\r\n\r\n\tvar lits = U.lits, strt=U.strt, prev=U.prev, li=0, lc=0, bs=0, ebits=0, c=0, nc=0;  // last_item, literal_count, block_start\r\n\tif(dlen>2) {  nc=UZIP.F._hash(data,0);  strt[nc]=0;  }\r\n\tvar nmch=0,nmci=0;\r\n\t\r\n\tfor(i=0; i<dlen; i++)  {\r\n\t\tc = nc;\r\n\t\t//*\r\n\t\tif(i+1<dlen-2) {\r\n\t\t\tnc = UZIP.F._hash(data, i+1);\r\n\t\t\tvar ii = ((i+1)&0x7fff);\r\n\t\t\tprev[ii]=strt[nc];\r\n\t\t\tstrt[nc]=ii;\r\n\t\t} //*/\r\n\t\tif(cvrd<=i) {\r\n\t\t\tif((li>14000 || lc>26697) && (dlen-i)>100) {\r\n\t\t\t\tif(cvrd<i) {  lits[li]=i-cvrd;  li+=2;  cvrd=i;  }\r\n\t\t\t\tpos = UZIP.F._writeBlock(((i==dlen-1) || (cvrd==dlen))?1:0, lits, li, ebits, data,bs,i-bs, out, pos);  li=lc=ebits=0;  bs=i;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar mch = 0;\r\n\t\t\t//if(nmci==i) mch= nmch;  else \r\n\t\t\tif(i<dlen-2) mch = UZIP.F._bestMatch(data, i, prev, c, Math.min(opt[2],dlen-i), opt[3]);\r\n\t\t\t/*\r\n\t\t\tif(mch!=0 && opt[4]==1 && (mch>>>16)<opt[1] && i+1<dlen-2) {\r\n\t\t\t\tnmch = UZIP.F._bestMatch(data, i+1, prev, nc, opt[2], opt[3]);  nmci=i+1;\r\n\t\t\t\t//var mch2 = UZIP.F._bestMatch(data, i+2, prev, nnc);  //nmci=i+1;\r\n\t\t\t\tif((nmch>>>16)>(mch>>>16)) mch=0;\r\n\t\t\t}//*/\r\n\t\t\tvar len = mch>>>16, dst = mch&0xffff;  //if(i-dst<0) throw \"e\";\r\n\t\t\tif(mch!=0) { \r\n\t\t\t\tvar len = mch>>>16, dst = mch&0xffff;  //if(i-dst<0) throw \"e\";\r\n\t\t\t\tvar lgi = goodIndex(len, U.of0);  U.lhst[257+lgi]++; \r\n\t\t\t\tvar dgi = goodIndex(dst, U.df0);  U.dhst[    dgi]++;  ebits += U.exb[lgi] + U.dxb[dgi]; \r\n\t\t\t\tlits[li] = (len<<23)|(i-cvrd);  lits[li+1] = (dst<<16)|(lgi<<8)|dgi;  li+=2;\r\n\t\t\t\tcvrd = i + len;  \r\n\t\t\t}\r\n\t\t\telse {\tU.lhst[data[i]]++;  }\r\n\t\t\tlc++;\r\n\t\t}\r\n\t}\r\n\tif(bs!=i || data.length==0) {\r\n\t\tif(cvrd<i) {  lits[li]=i-cvrd;  li+=2;  cvrd=i;  }\r\n\t\tpos = UZIP.F._writeBlock(1, lits, li, ebits, data,bs,i-bs, out, pos);  li=0;  lc=0;  li=lc=ebits=0;  bs=i;\r\n\t}\r\n\twhile((pos&7)!=0) pos++;\r\n\treturn pos>>>3;\r\n}\r\nUZIP.F._bestMatch = function(data, i, prev, c, nice, chain) {\r\n\tvar ci = (i&0x7fff), pi=prev[ci];  \r\n\t//console.log(\"----\", i);\r\n\tvar dif = ((ci-pi + (1<<15)) & 0x7fff);  if(pi==ci || c!=UZIP.F._hash(data,i-dif)) return 0;\r\n\tvar tl=0, td=0;  // top length, top distance\r\n\tvar dlim = Math.min(0x7fff, i);\r\n\twhile(dif<=dlim && --chain!=0 && pi!=ci /*&& c==UZIP.F._hash(data,i-dif)*/) {\r\n\t\tif(tl==0 || (data[i+tl]==data[i+tl-dif])) {\r\n\t\t\tvar cl = UZIP.F._howLong(data, i, dif);\r\n\t\t\tif(cl>tl) {  \r\n\t\t\t\ttl=cl;  td=dif;  if(tl>=nice) break;    //* \r\n\t\t\t\tif(dif+2<cl) cl = dif+2;\r\n\t\t\t\tvar maxd = 0; // pi does not point to the start of the word\r\n\t\t\t\tfor(var j=0; j<cl-2; j++) {\r\n\t\t\t\t\tvar ei =  (i-dif+j+ (1<<15)) & 0x7fff;\r\n\t\t\t\t\tvar li = prev[ei];\r\n\t\t\t\t\tvar curd = (ei-li + (1<<15)) & 0x7fff;\r\n\t\t\t\t\tif(curd>maxd) {  maxd=curd;  pi = ei; }\r\n\t\t\t\t}  //*/\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tci=pi;  pi = prev[ci];\r\n\t\tdif += ((ci-pi + (1<<15)) & 0x7fff);\r\n\t}\r\n\treturn (tl<<16)|td;\r\n}\r\nUZIP.F._howLong = function(data, i, dif) {\r\n\tif(data[i]!=data[i-dif] || data[i+1]!=data[i+1-dif] || data[i+2]!=data[i+2-dif]) return 0;\r\n\tvar oi=i, l = Math.min(data.length, i+258);  i+=3;\r\n\t//while(i+4<l && data[i]==data[i-dif] && data[i+1]==data[i+1-dif] && data[i+2]==data[i+2-dif] && data[i+3]==data[i+3-dif]) i+=4;\r\n\twhile(i<l && data[i]==data[i-dif]) i++;\r\n\treturn i-oi;\r\n}\r\nUZIP.F._hash = function(data, i) {\r\n\treturn (((data[i]<<8) | data[i+1])+(data[i+2]<<4))&0xffff;\r\n\t//var hash_shift = 0, hash_mask = 255;\r\n\t//var h = data[i+1] % 251;\r\n\t//h = (((h << 8) + data[i+2]) % 251);\r\n\t//h = (((h << 8) + data[i+2]) % 251);\r\n\t//h = ((h<<hash_shift) ^ (c) ) & hash_mask;\r\n\t//return h | (data[i]<<8);\r\n\t//return (data[i] | (data[i+1]<<8));\r\n}\r\n//UZIP.___toth = 0;\r\nUZIP.saved = 0;\r\nUZIP.F._writeBlock = function(BFINAL, lits, li, ebits, data,o0,l0, out, pos) {\r\n\tvar U = UZIP.F.U, putsF = UZIP.F._putsF, putsE = UZIP.F._putsE;\r\n\t\r\n\t//*\r\n\tvar T, ML, MD, MH, numl, numd, numh, lset, dset;  U.lhst[256]++;\r\n\tT = UZIP.F.getTrees(); ML=T[0]; MD=T[1]; MH=T[2]; numl=T[3]; numd=T[4]; numh=T[5]; lset=T[6]; dset=T[7];\r\n\t\r\n\tvar cstSize = (((pos+3)&7)==0 ? 0 : 8-((pos+3)&7)) + 32 + (l0<<3);\r\n\tvar fxdSize = ebits + UZIP.F.contSize(U.fltree, U.lhst) + UZIP.F.contSize(U.fdtree, U.dhst);\r\n\tvar dynSize = ebits + UZIP.F.contSize(U.ltree , U.lhst) + UZIP.F.contSize(U.dtree , U.dhst);\r\n\tdynSize    += 14 + 3*numh + UZIP.F.contSize(U.itree, U.ihst) + (U.ihst[16]*2 + U.ihst[17]*3 + U.ihst[18]*7);\r\n\t\r\n\tfor(var j=0; j<286; j++) U.lhst[j]=0;   for(var j=0; j<30; j++) U.dhst[j]=0;   for(var j=0; j<19; j++) U.ihst[j]=0;\r\n\t//*/\r\n\tvar BTYPE = (cstSize<fxdSize && cstSize<dynSize) ? 0 : ( fxdSize<dynSize ? 1 : 2 );\r\n\tputsF(out, pos, BFINAL);  putsF(out, pos+1, BTYPE);  pos+=3;\r\n\t\r\n\tvar opos = pos;\r\n\tif(BTYPE==0) {\r\n\t\twhile((pos&7)!=0) pos++;\r\n\t\tpos = UZIP.F._copyExact(data, o0, l0, out, pos);\r\n\t}\r\n\telse {\r\n\t\tvar ltree, dtree;\r\n\t\tif(BTYPE==1) {  ltree=U.fltree;  dtree=U.fdtree;  }\r\n\t\tif(BTYPE==2) {\t\r\n\t\t\tUZIP.F.makeCodes(U.ltree, ML);  UZIP.F.revCodes(U.ltree, ML);\r\n\t\t\tUZIP.F.makeCodes(U.dtree, MD);  UZIP.F.revCodes(U.dtree, MD);\r\n\t\t\tUZIP.F.makeCodes(U.itree, MH);  UZIP.F.revCodes(U.itree, MH);\r\n\t\t\t\r\n\t\t\tltree = U.ltree;  dtree = U.dtree;\r\n\t\t\t\r\n\t\t\tputsE(out, pos,numl-257);  pos+=5;  // 286\r\n\t\t\tputsE(out, pos,numd-  1);  pos+=5;  // 30\r\n\t\t\tputsE(out, pos,numh-  4);  pos+=4;  // 19\r\n\t\t\t\r\n\t\t\tfor(var i=0; i<numh; i++) putsE(out, pos+i*3, U.itree[(U.ordr[i]<<1)+1]);   pos+=3* numh;\r\n\t\t\tpos = UZIP.F._codeTiny(lset, U.itree, out, pos);\r\n\t\t\tpos = UZIP.F._codeTiny(dset, U.itree, out, pos);\r\n\t\t}\r\n\t\t\r\n\t\tvar off=o0;\r\n\t\tfor(var si=0; si<li; si+=2) {\r\n\t\t\tvar qb=lits[si], len=(qb>>>23), end = off+(qb&((1<<23)-1));\r\n\t\t\twhile(off<end) pos = UZIP.F._writeLit(data[off++], ltree, out, pos);\r\n\t\t\t\r\n\t\t\tif(len!=0) {\r\n\t\t\t\tvar qc = lits[si+1], dst=(qc>>16), lgi=(qc>>8)&255, dgi=(qc&255);\r\n\t\t\t\tpos = UZIP.F._writeLit(257+lgi, ltree, out, pos);\r\n\t\t\t\tputsE(out, pos, len-U.of0[lgi]);  pos+=U.exb[lgi];\r\n\t\t\t\t\r\n\t\t\t\tpos = UZIP.F._writeLit(dgi, dtree, out, pos);\r\n\t\t\t\tputsF(out, pos, dst-U.df0[dgi]);  pos+=U.dxb[dgi];  off+=len;\r\n\t\t\t}\r\n\t\t}\r\n\t\tpos = UZIP.F._writeLit(256, ltree, out, pos);\r\n\t}\r\n\t//console.log(pos-opos, fxdSize, dynSize, cstSize);\r\n\treturn pos;\r\n}\r\nUZIP.F._copyExact = function(data,off,len,out,pos) {\r\n\tvar p8 = (pos>>>3);\r\n\tout[p8]=(len);  out[p8+1]=(len>>>8);  out[p8+2]=255-out[p8];  out[p8+3]=255-out[p8+1];  p8+=4;\r\n\tout.set(new Uint8Array(data.buffer, off, len), p8);\r\n\t//for(var i=0; i<len; i++) out[p8+i]=data[off+i];\r\n\treturn pos + ((len+4)<<3);\r\n}\r\n/*\r\n\tInteresting facts:\r\n\t- decompressed block can have bytes, which do not occur in a Huffman tree (copied from the previous block by reference)\r\n*/\r\n\r\nUZIP.F.getTrees = function() {\r\n\tvar U = UZIP.F.U;\r\n\tvar ML = UZIP.F._hufTree(U.lhst, U.ltree, 15);\r\n\tvar MD = UZIP.F._hufTree(U.dhst, U.dtree, 15);\r\n\tvar lset = [], numl = UZIP.F._lenCodes(U.ltree, lset);\r\n\tvar dset = [], numd = UZIP.F._lenCodes(U.dtree, dset);\r\n\tfor(var i=0; i<lset.length; i+=2) U.ihst[lset[i]]++;\r\n\tfor(var i=0; i<dset.length; i+=2) U.ihst[dset[i]]++;\r\n\tvar MH = UZIP.F._hufTree(U.ihst, U.itree,  7);\r\n\tvar numh = 19;  while(numh>4 && U.itree[(U.ordr[numh-1]<<1)+1]==0) numh--;\r\n\treturn [ML, MD, MH, numl, numd, numh, lset, dset];\r\n}\r\nUZIP.F.getSecond= function(a) {  var b=[];  for(var i=0; i<a.length; i+=2) b.push  (a[i+1]);  return b;  }\r\nUZIP.F.nonZero  = function(a) {  var b= \"\";  for(var i=0; i<a.length; i+=2) if(a[i+1]!=0)b+=(i>>1)+\",\";  return b;  }\r\nUZIP.F.contSize = function(tree, hst) {  var s=0;  for(var i=0; i<hst.length; i++) s+= hst[i]*tree[(i<<1)+1];  return s;  }\r\nUZIP.F._codeTiny = function(set, tree, out, pos) {\r\n\tfor(var i=0; i<set.length; i+=2) {\r\n\t\tvar l = set[i], rst = set[i+1];  //console.log(l, pos, tree[(l<<1)+1]);\r\n\t\tpos = UZIP.F._writeLit(l, tree, out, pos);\r\n\t\tvar rsl = l==16 ? 2 : (l==17 ? 3 : 7);\r\n\t\tif(l>15) {  UZIP.F._putsE(out, pos, rst, rsl);  pos+=rsl;  }\r\n\t}\r\n\treturn pos;\r\n}\r\nUZIP.F._lenCodes = function(tree, set) {\r\n\tvar len=tree.length;  while(len!=2 && tree[len-1]==0) len-=2;  // when no distances, keep one code with length 0\r\n\tfor(var i=0; i<len; i+=2) {\r\n\t\tvar l = tree[i+1], nxt = (i+3<len ? tree[i+3]:-1),  nnxt = (i+5<len ? tree[i+5]:-1),  prv = (i==0 ? -1 : tree[i-1]);\r\n\t\tif(l==0 && nxt==l && nnxt==l) {\r\n\t\t\tvar lz = i+5;\r\n\t\t\twhile(lz+2<len && tree[lz+2]==l) lz+=2;\r\n\t\t\tvar zc = Math.min((lz+1-i)>>>1, 138);\r\n\t\t\tif(zc<11) set.push(17, zc-3);\r\n\t\t\telse set.push(18, zc-11);\r\n\t\t\ti += zc*2-2;\r\n\t\t}\r\n\t\telse if(l==prv && nxt==l && nnxt==l) {\r\n\t\t\tvar lz = i+5;\r\n\t\t\twhile(lz+2<len && tree[lz+2]==l) lz+=2;\r\n\t\t\tvar zc = Math.min((lz+1-i)>>>1, 6);\r\n\t\t\tset.push(16, zc-3);\r\n\t\t\ti += zc*2-2;\r\n\t\t}\r\n\t\telse set.push(l, 0);\r\n\t}\r\n\treturn len>>>1;\r\n}\r\nUZIP.F._hufTree   = function(hst, tree, MAXL) {\r\n\tvar list=[], hl = hst.length, tl=tree.length, i=0;\r\n\tfor(i=0; i<tl; i+=2) {  tree[i]=0;  tree[i+1]=0;  }\t\r\n\tfor(i=0; i<hl; i++) if(hst[i]!=0) list.push({lit:i, f:hst[i]});\r\n\tvar end = list.length, l2=list.slice(0);\r\n\tif(end==0) return 0;  // empty histogram (usually for dist)\r\n\tif(end==1) {  var lit=list[0].lit, l2=lit==0?1:0;  tree[(lit<<1)+1]=1;  tree[(l2<<1)+1]=1;  return 1;  }\r\n\tlist.sort(function(a,b){return a.f-b.f;});\r\n\tvar a=list[0], b=list[1], i0=0, i1=1, i2=2;  list[0]={lit:-1,f:a.f+b.f,l:a,r:b,d:0};\r\n\twhile(i1!=end-1) {\r\n\t\tif(i0!=i1 && (i2==end || list[i0].f<list[i2].f)) {  a=list[i0++];  }  else {  a=list[i2++];  }\r\n\t\tif(i0!=i1 && (i2==end || list[i0].f<list[i2].f)) {  b=list[i0++];  }  else {  b=list[i2++];  }\r\n\t\tlist[i1++]={lit:-1,f:a.f+b.f, l:a,r:b};\r\n\t}\r\n\tvar maxl = UZIP.F.setDepth(list[i1-1], 0);\r\n\tif(maxl>MAXL) {  UZIP.F.restrictDepth(l2, MAXL, maxl);  maxl = MAXL;  }\r\n\tfor(i=0; i<end; i++) tree[(l2[i].lit<<1)+1]=l2[i].d;\r\n\treturn maxl;\r\n}\r\n\r\nUZIP.F.setDepth  = function(t, d) {\r\n\tif(t.lit!=-1) {  t.d=d;  return d;  }\r\n\treturn Math.max( UZIP.F.setDepth(t.l, d+1),  UZIP.F.setDepth(t.r, d+1) );\r\n}\r\n\r\nUZIP.F.restrictDepth = function(dps, MD, maxl) {\r\n\tvar i=0, bCost=1<<(maxl-MD), dbt=0;\r\n\tdps.sort(function(a,b){return b.d==a.d ? a.f-b.f : b.d-a.d;});\r\n\t\r\n\tfor(i=0; i<dps.length; i++) if(dps[i].d>MD) {  var od=dps[i].d;  dps[i].d=MD;  dbt+=bCost-(1<<(maxl-od));  }  else break;\r\n\tdbt = dbt>>>(maxl-MD);\r\n\twhile(dbt>0) {  var od=dps[i].d;  if(od<MD) {  dps[i].d++;  dbt-=(1<<(MD-od-1));  }  else  i++;  }\r\n\tfor(; i>=0; i--) if(dps[i].d==MD && dbt<0) {  dps[i].d--;  dbt++;  }  if(dbt!=0) console.log(\"debt left\");\r\n}\r\n\r\nUZIP.F._goodIndex = function(v, arr) {\r\n\tvar i=0;  if(arr[i|16]<=v) i|=16;  if(arr[i|8]<=v) i|=8;  if(arr[i|4]<=v) i|=4;  if(arr[i|2]<=v) i|=2;  if(arr[i|1]<=v) i|=1;  return i;\r\n}\r\nUZIP.F._writeLit = function(ch, ltree, out, pos) {\r\n\tUZIP.F._putsF(out, pos, ltree[ch<<1]);\r\n\treturn pos+ltree[(ch<<1)+1];\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nUZIP.F.inflate = function(data, buf) {\r\n\tvar u8=Uint8Array;\r\n\tif(data[0]==3 && data[1]==0) return (buf ? buf : new u8(0));\r\n\tvar F=UZIP.F, bitsF = F._bitsF, bitsE = F._bitsE, decodeTiny = F._decodeTiny, makeCodes = F.makeCodes, codes2map=F.codes2map, get17 = F._get17;\r\n\tvar U = F.U;\r\n\t\r\n\tvar noBuf = (buf==null);\r\n\tif(noBuf) buf = new u8((data.length>>>2)<<3);\r\n\t\r\n\tvar BFINAL=0, BTYPE=0, HLIT=0, HDIST=0, HCLEN=0, ML=0, MD=0; \t\r\n\tvar off = 0, pos = 0;\r\n\tvar lmap, dmap;\r\n\t\r\n\twhile(BFINAL==0) {\t\t\r\n\t\tBFINAL = bitsF(data, pos  , 1);\r\n\t\tBTYPE  = bitsF(data, pos+1, 2);  pos+=3;\r\n\t\t//console.log(BFINAL, BTYPE);\r\n\t\t\r\n\t\tif(BTYPE==0) {\r\n\t\t\tif((pos&7)!=0) pos+=8-(pos&7);\r\n\t\t\tvar p8 = (pos>>>3)+4, len = data[p8-4]|(data[p8-3]<<8);  //console.log(len);//bitsF(data, pos, 16), \r\n\t\t\tif(noBuf) buf=UZIP.F._check(buf, off+len);\r\n\t\t\tbuf.set(new u8(data.buffer, data.byteOffset+p8, len), off);\r\n\t\t\t//for(var i=0; i<len; i++) buf[off+i] = data[p8+i];\r\n\t\t\t//for(var i=0; i<len; i++) if(buf[off+i] != data[p8+i]) throw \"e\";\r\n\t\t\tpos = ((p8+len)<<3);  off+=len;  continue;\r\n\t\t}\r\n\t\tif(noBuf) buf=UZIP.F._check(buf, off+(1<<17));  // really not enough in many cases (but PNG and ZIP provide buffer in advance)\r\n\t\tif(BTYPE==1) {  lmap = U.flmap;  dmap = U.fdmap;  ML = (1<<9)-1;  MD = (1<<5)-1;   }\r\n\t\tif(BTYPE==2) {\r\n\t\t\tHLIT  = bitsE(data, pos   , 5)+257;  \r\n\t\t\tHDIST = bitsE(data, pos+ 5, 5)+  1;  \r\n\t\t\tHCLEN = bitsE(data, pos+10, 4)+  4;  pos+=14;\r\n\t\t\t\r\n\t\t\tvar ppos = pos;\r\n\t\t\tfor(var i=0; i<38; i+=2) {  U.itree[i]=0;  U.itree[i+1]=0;  }\r\n\t\t\tvar tl = 1;\r\n\t\t\tfor(var i=0; i<HCLEN; i++) {  var l=bitsE(data, pos+i*3, 3);  U.itree[(U.ordr[i]<<1)+1] = l;  if(l>tl)tl=l;  }     pos+=3*HCLEN;  //console.log(itree);\r\n\t\t\tmakeCodes(U.itree, tl);\r\n\t\t\tcodes2map(U.itree, tl, U.imap);\r\n\t\t\t\r\n\t\t\tlmap = U.lmap;  dmap = U.dmap;\r\n\t\t\t\r\n\t\t\tpos = decodeTiny(U.imap, (1<<tl)-1, HLIT+HDIST, data, pos, U.ttree);\r\n\t\t\tvar mx0 = F._copyOut(U.ttree,    0, HLIT , U.ltree);  ML = (1<<mx0)-1;\r\n\t\t\tvar mx1 = F._copyOut(U.ttree, HLIT, HDIST, U.dtree);  MD = (1<<mx1)-1;\r\n\t\t\t\r\n\t\t\t//var ml = decodeTiny(U.imap, (1<<tl)-1, HLIT , data, pos, U.ltree); ML = (1<<(ml>>>24))-1;  pos+=(ml&0xffffff);\r\n\t\t\tmakeCodes(U.ltree, mx0);\r\n\t\t\tcodes2map(U.ltree, mx0, lmap);\r\n\t\t\t\r\n\t\t\t//var md = decodeTiny(U.imap, (1<<tl)-1, HDIST, data, pos, U.dtree); MD = (1<<(md>>>24))-1;  pos+=(md&0xffffff);\r\n\t\t\tmakeCodes(U.dtree, mx1);\r\n\t\t\tcodes2map(U.dtree, mx1, dmap);\r\n\t\t}\r\n\t\t//var ooff=off, opos=pos;\r\n\t\twhile(true) {\r\n\t\t\tvar code = lmap[get17(data, pos) & ML];  pos += code&15;\r\n\t\t\tvar lit = code>>>4;  //U.lhst[lit]++;  \r\n\t\t\tif((lit>>>8)==0) {  buf[off++] = lit;  }\r\n\t\t\telse if(lit==256) {  break;  }\r\n\t\t\telse {\r\n\t\t\t\tvar end = off+lit-254;\r\n\t\t\t\tif(lit>264) { var ebs = U.ldef[lit-257];  end = off + (ebs>>>3) + bitsE(data, pos, ebs&7);  pos += ebs&7;  }\r\n\t\t\t\t//UZIP.F.dst[end-off]++;\r\n\t\t\t\t\r\n\t\t\t\tvar dcode = dmap[get17(data, pos) & MD];  pos += dcode&15;\r\n\t\t\t\tvar dlit = dcode>>>4;\r\n\t\t\t\tvar dbs = U.ddef[dlit], dst = (dbs>>>4) + bitsF(data, pos, dbs&15);  pos += dbs&15;\r\n\t\t\t\t\r\n\t\t\t\t//var o0 = off-dst, stp = Math.min(end-off, dst);\r\n\t\t\t\t//if(stp>20) while(off<end) {  buf.copyWithin(off, o0, o0+stp);  off+=stp;  }  else\r\n\t\t\t\t//if(end-dst<=off) buf.copyWithin(off, off-dst, end-dst);  else\r\n\t\t\t\t//if(dst==1) buf.fill(buf[off-1], off, end);  else\r\n\t\t\t\tif(noBuf) buf=UZIP.F._check(buf, off+(1<<17));\r\n\t\t\t\twhile(off<end) {  buf[off]=buf[off++-dst];    buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  buf[off]=buf[off++-dst];  }   \r\n\t\t\t\toff=end;\r\n\t\t\t\t//while(off!=end) {  buf[off]=buf[off++-dst];  }\r\n\t\t\t}\r\n\t\t}\r\n\t\t//console.log(off-ooff, (pos-opos)>>>3);\r\n\t}\r\n\t//console.log(UZIP.F.dst);\r\n\t//console.log(tlen, dlen, off-tlen+tcnt);\r\n\treturn buf.length==off ? buf : buf.slice(0,off);\r\n}\r\nUZIP.F._check=function(buf, len) {\r\n\tvar bl=buf.length;  if(len<=bl) return buf;\r\n\tvar nbuf = new Uint8Array(Math.max(bl<<1,len));  nbuf.set(buf,0);\r\n\t//for(var i=0; i<bl; i+=4) {  nbuf[i]=buf[i];  nbuf[i+1]=buf[i+1];  nbuf[i+2]=buf[i+2];  nbuf[i+3]=buf[i+3];  }\r\n\treturn nbuf;\r\n}\r\n\r\nUZIP.F._decodeTiny = function(lmap, LL, len, data, pos, tree) {\r\n\tvar bitsE = UZIP.F._bitsE, get17 = UZIP.F._get17;\r\n\tvar i = 0;\r\n\twhile(i<len) {\r\n\t\tvar code = lmap[get17(data, pos)&LL];  pos+=code&15;\r\n\t\tvar lit = code>>>4; \r\n\t\tif(lit<=15) {  tree[i]=lit;  i++;  }\r\n\t\telse {\r\n\t\t\tvar ll = 0, n = 0;\r\n\t\t\tif(lit==16) {\r\n\t\t\t\tn = (3  + bitsE(data, pos, 2));  pos += 2;  ll = tree[i-1];\r\n\t\t\t}\r\n\t\t\telse if(lit==17) {\r\n\t\t\t\tn = (3  + bitsE(data, pos, 3));  pos += 3;\r\n\t\t\t}\r\n\t\t\telse if(lit==18) {\r\n\t\t\t\tn = (11 + bitsE(data, pos, 7));  pos += 7;\r\n\t\t\t}\r\n\t\t\tvar ni = i+n;\r\n\t\t\twhile(i<ni) {  tree[i]=ll;  i++; }\r\n\t\t}\r\n\t}\r\n\treturn pos;\r\n}\r\nUZIP.F._copyOut = function(src, off, len, tree) {\r\n\tvar mx=0, i=0, tl=tree.length>>>1;\r\n\twhile(i<len) {  var v=src[i+off];  tree[(i<<1)]=0;  tree[(i<<1)+1]=v;  if(v>mx)mx=v;  i++;  }\r\n\twhile(i<tl ) {  tree[(i<<1)]=0;  tree[(i<<1)+1]=0;  i++;  }\r\n\treturn mx;\r\n}\r\n\r\nUZIP.F.makeCodes = function(tree, MAX_BITS) {  // code, length\r\n\tvar U = UZIP.F.U;\r\n\tvar max_code = tree.length;\r\n\tvar code, bits, n, i, len;\r\n\t\r\n\tvar bl_count = U.bl_count;  for(var i=0; i<=MAX_BITS; i++) bl_count[i]=0;\r\n\tfor(i=1; i<max_code; i+=2) bl_count[tree[i]]++;\r\n\t\r\n\tvar next_code = U.next_code;\t// smallest code for each length\r\n\t\r\n\tcode = 0;\r\n\tbl_count[0] = 0;\r\n\tfor (bits = 1; bits <= MAX_BITS; bits++) {\r\n\t\tcode = (code + bl_count[bits-1]) << 1;\r\n\t\tnext_code[bits] = code;\r\n\t}\r\n\t\r\n\tfor (n = 0; n < max_code; n+=2) {\r\n\t\tlen = tree[n+1];\r\n\t\tif (len != 0) {\r\n\t\t\ttree[n] = next_code[len];\r\n\t\t\tnext_code[len]++;\r\n\t\t}\r\n\t}\r\n}\r\nUZIP.F.codes2map = function(tree, MAX_BITS, map) {\r\n\tvar max_code = tree.length;\r\n\tvar U=UZIP.F.U, r15 = U.rev15;\r\n\tfor(var i=0; i<max_code; i+=2) if(tree[i+1]!=0)  {\r\n\t\tvar lit = i>>1;\r\n\t\tvar cl = tree[i+1], val = (lit<<4)|cl; // :  (0x8000 | (U.of0[lit-257]<<7) | (U.exb[lit-257]<<4) | cl);\r\n\t\tvar rest = (MAX_BITS-cl), i0 = tree[i]<<rest, i1 = i0 + (1<<rest);\r\n\t\t//tree[i]=r15[i0]>>>(15-MAX_BITS);\r\n\t\twhile(i0!=i1) {\r\n\t\t\tvar p0 = r15[i0]>>>(15-MAX_BITS);\r\n\t\t\tmap[p0]=val;  i0++;\r\n\t\t}\r\n\t}\r\n}\r\nUZIP.F.revCodes = function(tree, MAX_BITS) {\r\n\tvar r15 = UZIP.F.U.rev15, imb = 15-MAX_BITS;\r\n\tfor(var i=0; i<tree.length; i+=2) {  var i0 = (tree[i]<<(MAX_BITS-tree[i+1]));  tree[i] = r15[i0]>>>imb;  }\r\n}\r\n\r\n// used only in deflate\r\nUZIP.F._putsE= function(dt, pos, val   ) {  val = val<<(pos&7);  var o=(pos>>>3);  dt[o]|=val;  dt[o+1]|=(val>>>8);                        }\r\nUZIP.F._putsF= function(dt, pos, val   ) {  val = val<<(pos&7);  var o=(pos>>>3);  dt[o]|=val;  dt[o+1]|=(val>>>8);  dt[o+2]|=(val>>>16);  }\r\n\r\nUZIP.F._bitsE= function(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8)                        )>>>(pos&7))&((1<<length)-1);  }\r\nUZIP.F._bitsF= function(dt, pos, length) {  return ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16))>>>(pos&7))&((1<<length)-1);  }\r\n/*\r\nUZIP.F._get9 = function(dt, pos) {\r\n\treturn ((dt[pos>>>3] | (dt[(pos>>>3)+1]<<8))>>>(pos&7))&511;\r\n} */\r\nUZIP.F._get17= function(dt, pos) {\t// return at least 17 meaningful bytes\r\n\treturn (dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16) )>>>(pos&7);\r\n}\r\nUZIP.F._get25= function(dt, pos) {\t// return at least 17 meaningful bytes\r\n\treturn (dt[pos>>>3] | (dt[(pos>>>3)+1]<<8) | (dt[(pos>>>3)+2]<<16) | (dt[(pos>>>3)+3]<<24) )>>>(pos&7);\r\n}\r\nUZIP.F.U = function(){\r\n\tvar u16=Uint16Array, u32=Uint32Array;\r\n\treturn {\r\n\t\tnext_code : new u16(16),\r\n\t\tbl_count  : new u16(16),\r\n\t\tordr : [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ],\r\n\t\tof0  : [3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],\r\n\t\texb  : [0,0,0,0,0,0,0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,  4,  5,  5,  5,  5,  0,  0,  0,  0],\r\n\t\tldef : new u16(32),\r\n\t\tdf0  : [1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577, 65535, 65535],\r\n\t\tdxb  : [0,0,0,0,1,1,2, 2, 3, 3, 4, 4, 5, 5,  6,  6,  7,  7,  8,  8,   9,   9,  10,  10,  11,  11,  12,   12,   13,   13,     0,     0],\r\n\t\tddef : new u32(32),\r\n\t\tflmap: new u16(  512),  fltree: [],\r\n\t\tfdmap: new u16(   32),  fdtree: [],\r\n\t\tlmap : new u16(32768),  ltree : [],  ttree:[],\r\n\t\tdmap : new u16(32768),  dtree : [],\r\n\t\timap : new u16(  512),  itree : [],\r\n\t\t//rev9 : new u16(  512)\r\n\t\trev15: new u16(1<<15),\r\n\t\tlhst : new u32(286), dhst : new u32( 30), ihst : new u32(19),\r\n\t\tlits : new u32(15000),\r\n\t\tstrt : new u16(1<<16),\r\n\t\tprev : new u16(1<<15)\r\n\t};  \r\n} ();\r\n\r\n(function(){\t\r\n\tvar U = UZIP.F.U;\r\n\tvar len = 1<<15;\r\n\tfor(var i=0; i<len; i++) {\r\n\t\tvar x = i;\r\n\t\tx = (((x & 0xaaaaaaaa) >>> 1) | ((x & 0x55555555) << 1));\r\n\t\tx = (((x & 0xcccccccc) >>> 2) | ((x & 0x33333333) << 2));\r\n\t\tx = (((x & 0xf0f0f0f0) >>> 4) | ((x & 0x0f0f0f0f) << 4));\r\n\t\tx = (((x & 0xff00ff00) >>> 8) | ((x & 0x00ff00ff) << 8));\r\n\t\tU.rev15[i] = (((x >>> 16) | (x << 16)))>>>17;\r\n\t}\r\n\t\r\n\tfunction pushV(tgt, n, sv) {  while(n--!=0) tgt.push(0,sv);  }\r\n\t\r\n\tfor(var i=0; i<32; i++) {  U.ldef[i]=(U.of0[i]<<3)|U.exb[i];  U.ddef[i]=(U.df0[i]<<4)|U.dxb[i];  }\r\n\t\r\n\tpushV(U.fltree, 144, 8);  pushV(U.fltree, 255-143, 9);  pushV(U.fltree, 279-255, 7);  pushV(U.fltree,287-279,8);\r\n\t/*\r\n\tvar i = 0;\r\n\tfor(; i<=143; i++) U.fltree.push(0,8);\r\n\tfor(; i<=255; i++) U.fltree.push(0,9);\r\n\tfor(; i<=279; i++) U.fltree.push(0,7);\r\n\tfor(; i<=287; i++) U.fltree.push(0,8);\r\n\t*/\r\n\tUZIP.F.makeCodes(U.fltree, 9);\r\n\tUZIP.F.codes2map(U.fltree, 9, U.flmap);\r\n\tUZIP.F.revCodes (U.fltree, 9)\r\n\t\r\n\tpushV(U.fdtree,32,5);\r\n\t//for(i=0;i<32; i++) U.fdtree.push(0,5);\r\n\tUZIP.F.makeCodes(U.fdtree, 5);\r\n\tUZIP.F.codes2map(U.fdtree, 5, U.fdmap);\r\n\tUZIP.F.revCodes (U.fdtree, 5)\r\n\t\r\n\tpushV(U.itree,19,0);  pushV(U.ltree,286,0);  pushV(U.dtree,30,0);  pushV(U.ttree,320,0);\r\n\t/*\r\n\tfor(var i=0; i< 19; i++) U.itree.push(0,0);\r\n\tfor(var i=0; i<286; i++) U.ltree.push(0,0);\r\n\tfor(var i=0; i< 30; i++) U.dtree.push(0,0);\r\n\tfor(var i=0; i<320; i++) U.ttree.push(0,0);\r\n\t*/\r\n})()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","// https://github.com/photopea/UPNG.js/blob/f6e5f93da01094b1ffb3cef364abce4d9e758cbf/UPNG.js\n\n// import * as pako from 'pako'\nimport * as UZIP from 'uzip';\n\nconst UPNG = (function () {\n  var _bin = {\n    nextZero(data, p) { while (data[p] != 0) p++; return p; },\n    readUshort(buff, p) { return (buff[p] << 8) | buff[p + 1]; },\n    writeUshort(buff, p, n) { buff[p] = (n >> 8) & 255; buff[p + 1] = n & 255; },\n    readUint(buff, p) { return (buff[p] * (256 * 256 * 256)) + ((buff[p + 1] << 16) | (buff[p + 2] << 8) | buff[p + 3]); },\n    writeUint(buff, p, n) { buff[p] = (n >> 24) & 255; buff[p + 1] = (n >> 16) & 255; buff[p + 2] = (n >> 8) & 255; buff[p + 3] = n & 255; },\n    readASCII(buff, p, l) { let s = ''; for (let i = 0; i < l; i++) s += String.fromCharCode(buff[p + i]); return s; },\n    writeASCII(data, p, s) { for (let i = 0; i < s.length; i++) data[p + i] = s.charCodeAt(i); },\n    readBytes(buff, p, l) { const arr = []; for (let i = 0; i < l; i++) arr.push(buff[p + i]); return arr; },\n    pad(n) { return n.length < 2 ? `0${n}` : n; },\n    readUTF8(buff, p, l) {\n      let s = '';\n      let ns;\n      for (let i = 0; i < l; i++) s += `%${_bin.pad(buff[p + i].toString(16))}`;\n      try { ns = decodeURIComponent(s); } catch (e) { return _bin.readASCII(buff, p, l); }\n      return ns;\n    },\n  };\n\n  function toRGBA8(out) {\n    const w = out.width; const\n      h = out.height;\n    if (out.tabs.acTL == null) return [decodeImage(out.data, w, h, out).buffer];\n\n    const frms = [];\n    if (out.frames[0].data == null) out.frames[0].data = out.data;\n\n    const len = w * h * 4; const img = new Uint8Array(len); const empty = new Uint8Array(len); const\n      prev = new Uint8Array(len);\n    for (let i = 0; i < out.frames.length; i++) {\n      const frm = out.frames[i];\n      const fx = frm.rect.x; const fy = frm.rect.y; const fw = frm.rect.width; const\n        fh = frm.rect.height;\n      const fdata = decodeImage(frm.data, fw, fh, out);\n\n      if (i != 0) for (var j = 0; j < len; j++) prev[j] = img[j];\n\n      if (frm.blend == 0) _copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);\n      else if (frm.blend == 1) _copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);\n\n      frms.push(img.buffer.slice(0));\n\n      if (frm.dispose == 0) {} else if (frm.dispose == 1) _copyTile(empty, fw, fh, img, w, h, fx, fy, 0);\n      else if (frm.dispose == 2) for (var j = 0; j < len; j++) img[j] = prev[j];\n    }\n    return frms;\n  }\n  function decodeImage(data, w, h, out) {\n    const area = w * h; const\n      bpp = _getBPP(out);\n    const bpl = Math.ceil(w * bpp / 8);\t// bytes per line\n\n    const bf = new Uint8Array(area * 4); const\n      bf32 = new Uint32Array(bf.buffer);\n    const { ctype } = out;\n    const { depth } = out;\n    const rs = _bin.readUshort;\n\n    // console.log(ctype, depth);\n    const time = Date.now();\n\n    if (ctype == 6) { // RGB + alpha\n      const qarea = area << 2;\n      if (depth == 8) for (var i = 0; i < qarea; i += 4) { bf[i] = data[i]; bf[i + 1] = data[i + 1]; bf[i + 2] = data[i + 2]; bf[i + 3] = data[i + 3]; }\n      if (depth == 16) for (var i = 0; i < qarea; i++) { bf[i] = data[i << 1]; }\n    } else if (ctype == 2) {\t// RGB\n      const ts = out.tabs.tRNS;\n      if (ts == null) {\n        if (depth == 8) for (var i = 0; i < area; i++) { var ti = i * 3; bf32[i] = (255 << 24) | (data[ti + 2] << 16) | (data[ti + 1] << 8) | data[ti]; }\n        if (depth == 16) for (var i = 0; i < area; i++) { var ti = i * 6; bf32[i] = (255 << 24) | (data[ti + 4] << 16) | (data[ti + 2] << 8) | data[ti]; }\n      } else {\n        var tr = ts[0]; const tg = ts[1]; const\n          tb = ts[2];\n        if (depth == 8) {\n          for (var i = 0; i < area; i++) {\n            var qi = i << 2; var\n              ti = i * 3; bf32[i] = (255 << 24) | (data[ti + 2] << 16) | (data[ti + 1] << 8) | data[ti];\n            if (data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb) bf[qi + 3] = 0;\n          }\n        }\n        if (depth == 16) {\n          for (var i = 0; i < area; i++) {\n            var qi = i << 2; var\n              ti = i * 6; bf32[i] = (255 << 24) | (data[ti + 4] << 16) | (data[ti + 2] << 8) | data[ti];\n            if (rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb) bf[qi + 3] = 0;\n          }\n        }\n      }\n    } else if (ctype == 3) {\t// palette\n      const p = out.tabs.PLTE;\n      const ap = out.tabs.tRNS;\n      const tl = ap ? ap.length : 0;\n      // console.log(p, ap);\n      if (depth == 1) {\n        for (var y = 0; y < h; y++) {\n          var s0 = y * bpl; var\n            t0 = y * w;\n          for (var i = 0; i < w; i++) {\n            var qi = (t0 + i) << 2; var j = ((data[s0 + (i >> 3)] >> (7 - ((i & 7) << 0))) & 1); var\n              cj = 3 * j; bf[qi] = p[cj]; bf[qi + 1] = p[cj + 1]; bf[qi + 2] = p[cj + 2]; bf[qi + 3] = (j < tl) ? ap[j] : 255;\n          }\n        }\n      }\n      if (depth == 2) {\n        for (var y = 0; y < h; y++) {\n          var s0 = y * bpl; var\n            t0 = y * w;\n          for (var i = 0; i < w; i++) {\n            var qi = (t0 + i) << 2; var j = ((data[s0 + (i >> 2)] >> (6 - ((i & 3) << 1))) & 3); var\n              cj = 3 * j; bf[qi] = p[cj]; bf[qi + 1] = p[cj + 1]; bf[qi + 2] = p[cj + 2]; bf[qi + 3] = (j < tl) ? ap[j] : 255;\n          }\n        }\n      }\n      if (depth == 4) {\n        for (var y = 0; y < h; y++) {\n          var s0 = y * bpl; var\n            t0 = y * w;\n          for (var i = 0; i < w; i++) {\n            var qi = (t0 + i) << 2; var j = ((data[s0 + (i >> 1)] >> (4 - ((i & 1) << 2))) & 15); var\n              cj = 3 * j; bf[qi] = p[cj]; bf[qi + 1] = p[cj + 1]; bf[qi + 2] = p[cj + 2]; bf[qi + 3] = (j < tl) ? ap[j] : 255;\n          }\n        }\n      }\n      if (depth == 8) {\n        for (var i = 0; i < area; i++) {\n          var qi = i << 2; var j = data[i]; var\n            cj = 3 * j; bf[qi] = p[cj]; bf[qi + 1] = p[cj + 1]; bf[qi + 2] = p[cj + 2]; bf[qi + 3] = (j < tl) ? ap[j] : 255;\n        }\n      }\n    } else if (ctype == 4) {\t// gray + alpha\n      if (depth == 8) {\n        for (var i = 0; i < area; i++) {\n          var qi = i << 2; var di = i << 1; var\n            gr = data[di]; bf[qi] = gr; bf[qi + 1] = gr; bf[qi + 2] = gr; bf[qi + 3] = data[di + 1];\n        }\n      }\n      if (depth == 16) {\n        for (var i = 0; i < area; i++) {\n          var qi = i << 2; var di = i << 2; var\n            gr = data[di]; bf[qi] = gr; bf[qi + 1] = gr; bf[qi + 2] = gr; bf[qi + 3] = data[di + 2];\n        }\n      }\n    } else if (ctype == 0) {\t// gray\n      var tr = out.tabs.tRNS ? out.tabs.tRNS : -1;\n      for (var y = 0; y < h; y++) {\n        const off = y * bpl; const\n          to = y * w;\n        if (depth == 1) {\n          for (var x = 0; x < w; x++) {\n            var gr = 255 * ((data[off + (x >>> 3)] >>> (7 - ((x & 7)))) & 1); var\n              al = (gr == tr * 255) ? 0 : 255; bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr;\n          }\n        } else if (depth == 2) {\n          for (var x = 0; x < w; x++) {\n            var gr = 85 * ((data[off + (x >>> 2)] >>> (6 - ((x & 3) << 1))) & 3); var\n              al = (gr == tr * 85) ? 0 : 255; bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr;\n          }\n        } else if (depth == 4) {\n          for (var x = 0; x < w; x++) {\n            var gr = 17 * ((data[off + (x >>> 1)] >>> (4 - ((x & 1) << 2))) & 15); var\n              al = (gr == tr * 17) ? 0 : 255; bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr;\n          }\n        } else if (depth == 8) {\n          for (var x = 0; x < w; x++) {\n            var gr = data[off + x]; var\n              al = (gr == tr) ? 0 : 255; bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr;\n          }\n        } else if (depth == 16) {\n          for (var x = 0; x < w; x++) {\n            var gr = data[off + (x << 1)]; var\n              al = (rs(data, off + (x << 1)) == tr) ? 0 : 255; bf32[to + x] = (al << 24) | (gr << 16) | (gr << 8) | gr;\n          }\n        }\n      }\n    }\n    // console.log(Date.now()-time);\n    return bf;\n  }\n\n  function decode(buff) {\n    const data = new Uint8Array(buff); let offset = 8; const bin = _bin; const rUs = bin.readUshort; const\n      rUi = bin.readUint;\n    const out = { tabs: {}, frames: [] };\n    const dd = new Uint8Array(data.length); let\n      doff = 0;\t // put all IDAT data into it\n    let fd; let\n      foff = 0;\t// frames\n\n    const mgck = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n    for (var i = 0; i < 8; i++) if (data[i] != mgck[i]) throw 'The input is not a PNG file!';\n\n    while (offset < data.length) {\n      const len = bin.readUint(data, offset); offset += 4;\n      const type = bin.readASCII(data, offset, 4); offset += 4;\n      // console.log(type,len);\n\n      if (type == 'IHDR') { _IHDR(data, offset, out); } else if (type == 'iCCP') {\n        var off = offset; while (data[off] != 0) off++;\n        const nam = bin.readASCII(data, offset, off - offset);\n        const cpr = data[off + 1];\n        const fil = data.slice(off + 2, offset + len);\n        let res = null;\n        try { res = _inflate(fil); } catch (e) { res = inflateRaw(fil); }\n        out.tabs[type] = res;\n      } else if (type == 'CgBI') { out.tabs[type] = data.slice(offset, offset + 4); } else if (type == 'IDAT') {\n        for (var i = 0; i < len; i++) dd[doff + i] = data[offset + i];\n        doff += len;\n      } else if (type == 'acTL') {\n        out.tabs[type] = { num_frames: rUi(data, offset), num_plays: rUi(data, offset + 4) };\n        fd = new Uint8Array(data.length);\n      } else if (type == 'fcTL') {\n        if (foff != 0) {\n          var fr = out.frames[out.frames.length - 1];\n          fr.data = _decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height); foff = 0;\n        }\n        const rct = {\n          x: rUi(data, offset + 12), y: rUi(data, offset + 16), width: rUi(data, offset + 4), height: rUi(data, offset + 8),\n        };\n        let del = rUs(data, offset + 22); del = rUs(data, offset + 20) / (del == 0 ? 100 : del);\n        const frm = {\n          rect: rct, delay: Math.round(del * 1000), dispose: data[offset + 24], blend: data[offset + 25],\n        };\n        // console.log(frm);\n        out.frames.push(frm);\n      } else if (type == 'fdAT') {\n        for (var i = 0; i < len - 4; i++) fd[foff + i] = data[offset + i + 4];\n        foff += len - 4;\n      } else if (type == 'pHYs') {\n        out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];\n      } else if (type == 'cHRM') {\n        out.tabs[type] = [];\n        for (var i = 0; i < 8; i++) out.tabs[type].push(bin.readUint(data, offset + i * 4));\n      } else if (type == 'tEXt' || type == 'zTXt') {\n        if (out.tabs[type] == null) out.tabs[type] = {};\n        var nz = bin.nextZero(data, offset);\n        var keyw = bin.readASCII(data, offset, nz - offset);\n        var text; var\n          tl = offset + len - nz - 1;\n        if (type == 'tEXt') text = bin.readASCII(data, nz + 1, tl);\n        else {\n          var bfr = _inflate(data.slice(nz + 2, nz + 2 + tl));\n          text = bin.readUTF8(bfr, 0, bfr.length);\n        }\n        out.tabs[type][keyw] = text;\n      } else if (type == 'iTXt') {\n        if (out.tabs[type] == null) out.tabs[type] = {};\n        var nz = 0; var\n          off = offset;\n        nz = bin.nextZero(data, off);\n        var keyw = bin.readASCII(data, off, nz - off); off = nz + 1;\n        const cflag = data[off]; const\n          cmeth = data[off + 1]; off += 2;\n        nz = bin.nextZero(data, off);\n        const ltag = bin.readASCII(data, off, nz - off); off = nz + 1;\n        nz = bin.nextZero(data, off);\n        const tkeyw = bin.readUTF8(data, off, nz - off); off = nz + 1;\n        var text; var\n          tl = len - (off - offset);\n        if (cflag == 0) text = bin.readUTF8(data, off, tl);\n        else {\n          var bfr = _inflate(data.slice(off, off + tl));\n          text = bin.readUTF8(bfr, 0, bfr.length);\n        }\n        out.tabs[type][keyw] = text;\n      } else if (type == 'PLTE') {\n        out.tabs[type] = bin.readBytes(data, offset, len);\n      } else if (type == 'hIST') {\n        const pl = out.tabs.PLTE.length / 3;\n        out.tabs[type] = []; for (var i = 0; i < pl; i++) out.tabs[type].push(rUs(data, offset + i * 2));\n      } else if (type == 'tRNS') {\n        if (out.ctype == 3) out.tabs[type] = bin.readBytes(data, offset, len);\n        else if (out.ctype == 0) out.tabs[type] = rUs(data, offset);\n        else if (out.ctype == 2) out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];\n        // else console.log(\"tRNS for unsupported color type\",out.ctype, len);\n      } else if (type == 'gAMA') out.tabs[type] = bin.readUint(data, offset) / 100000;\n      else if (type == 'sRGB') out.tabs[type] = data[offset];\n      else if (type == 'bKGD') {\n        if (out.ctype == 0 || out.ctype == 4) out.tabs[type] = [rUs(data, offset)];\n        else if (out.ctype == 2 || out.ctype == 6) out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];\n        else if (out.ctype == 3) out.tabs[type] = data[offset];\n      } else if (type == 'IEND') {\n        break;\n      }\n      // else {  console.log(\"unknown chunk type\", type, len);  out.tabs[type]=data.slice(offset,offset+len);  }\n      offset += len;\n      const crc = bin.readUint(data, offset); offset += 4;\n    }\n    if (foff != 0) {\n      var fr = out.frames[out.frames.length - 1];\n      fr.data = _decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\n    }\n    out.data = _decompress(out, dd, out.width, out.height);\n\n    delete out.compress; delete out.interlace; delete out.filter;\n    return out;\n  }\n\n  function _decompress(out, dd, w, h) {\n    var time = Date.now();\n    const bpp = _getBPP(out); const bpl = Math.ceil(w * bpp / 8); const\n      buff = new Uint8Array((bpl + 1 + out.interlace) * h);\n    if (out.tabs.CgBI) dd = inflateRaw(dd, buff);\n    else dd = _inflate(dd, buff);\n    // console.log(dd.length, buff.length);\n    // console.log(Date.now()-time);\n\n    var time = Date.now();\n    if (out.interlace == 0) dd = _filterZero(dd, out, 0, w, h);\n    else if (out.interlace == 1) dd = _readInterlace(dd, out);\n    // console.log(Date.now()-time);\n    return dd;\n  }\n\n  function _inflate(data, buff) { const out = inflateRaw(new Uint8Array(data.buffer, 2, data.length - 6), buff); return out; }\n\n  var inflateRaw = (function () {\n    const H = {}; H.H = {}; H.H.N = function (N, W) {\n      const R = Uint8Array; let i = 0; let m = 0; let J = 0; let h = 0; let Q = 0; let X = 0; let u = 0; let w = 0; let d = 0; let v; let C;\n      if (N[0] == 3 && N[1] == 0) return W || new R(0); const V = H.H; const n = V.b; const A = V.e; const l = V.R; const M = V.n; const I = V.A; const e = V.Z; const b = V.m; const Z = W == null;\n      if (Z)W = new R(N.length >>> 2 << 5); while (i == 0) {\n        i = n(N, d, 1); m = n(N, d + 1, 2); d += 3; if (m == 0) {\n          if ((d & 7) != 0)d += 8 - (d & 7);\n          const D = (d >>> 3) + 4; const q = N[D - 4] | N[D - 3] << 8; if (Z)W = H.H.W(W, w + q); W.set(new R(N.buffer, N.byteOffset + D, q), w); d = D + q << 3;\n          w += q; continue;\n        } if (Z)W = H.H.W(W, w + (1 << 17)); if (m == 1) { v = b.J; C = b.h; X = (1 << 9) - 1; u = (1 << 5) - 1; } if (m == 2) {\n          J = A(N, d, 5) + 257;\n          h = A(N, d + 5, 5) + 1; Q = A(N, d + 10, 4) + 4; d += 14; const E = d; let j = 1; for (var c = 0; c < 38; c += 2) { b.Q[c] = 0; b.Q[c + 1] = 0; } for (var c = 0;\n            c < Q; c++) { const K = A(N, d + c * 3, 3); b.Q[(b.X[c] << 1) + 1] = K; if (K > j)j = K; }d += 3 * Q; M(b.Q, j); I(b.Q, j, b.u); v = b.w; C = b.d;\n          d = l(b.u, (1 << j) - 1, J + h, N, d, b.v); const r = V.V(b.v, 0, J, b.C); X = (1 << r) - 1; const S = V.V(b.v, J, h, b.D); u = (1 << S) - 1; M(b.C, r);\n          I(b.C, r, v); M(b.D, S); I(b.D, S, C);\n        } while (!0) {\n          const T = v[e(N, d) & X]; d += T & 15; const p = T >>> 4; if (p >>> 8 == 0) { W[w++] = p; } else if (p == 256) { break; } else {\n            let z = w + p - 254;\n            if (p > 264) { const _ = b.q[p - 257]; z = w + (_ >>> 3) + A(N, d, _ & 7); d += _ & 7; } const $ = C[e(N, d) & u]; d += $ & 15; const s = $ >>> 4; const Y = b.c[s]; const a = (Y >>> 4) + n(N, d, Y & 15);\n            d += Y & 15; while (w < z) { W[w] = W[w++ - a]; W[w] = W[w++ - a]; W[w] = W[w++ - a]; W[w] = W[w++ - a]; }w = z;\n          }\n        }\n      } return W.length == w ? W : W.slice(0, w);\n    };\n    H.H.W = function (N, W) { const R = N.length; if (W <= R) return N; const V = new Uint8Array(R << 1); V.set(N, 0); return V; };\n    H.H.R = function (N, W, R, V, n, A) {\n      const l = H.H.e; const M = H.H.Z; let I = 0; while (I < R) {\n        const e = N[M(V, n) & W]; n += e & 15; const b = e >>> 4;\n        if (b <= 15) { A[I] = b; I++; } else {\n          let Z = 0; let m = 0; if (b == 16) { m = 3 + l(V, n, 2); n += 2; Z = A[I - 1]; } else if (b == 17) {\n            m = 3 + l(V, n, 3);\n            n += 3;\n          } else if (b == 18) { m = 11 + l(V, n, 7); n += 7; } const J = I + m; while (I < J) { A[I] = Z; I++; }\n        }\n      } return n;\n    }; H.H.V = function (N, W, R, V) {\n      let n = 0; let A = 0; const l = V.length >>> 1;\n      while (A < R) { const M = N[A + W]; V[A << 1] = 0; V[(A << 1) + 1] = M; if (M > n)n = M; A++; } while (A < l) { V[A << 1] = 0; V[(A << 1) + 1] = 0; A++; } return n;\n    };\n    H.H.n = function (N, W) {\n      const R = H.H.m; const V = N.length; let n; let A; let l; var M; let I; const e = R.j; for (var M = 0; M <= W; M++)e[M] = 0; for (M = 1; M < V; M += 2)e[N[M]]++;\n      const b = R.K; n = 0; e[0] = 0; for (A = 1; A <= W; A++) { n = n + e[A - 1] << 1; b[A] = n; } for (l = 0; l < V; l += 2) {\n        I = N[l + 1]; if (I != 0) {\n          N[l] = b[I];\n          b[I]++;\n        }\n      }\n    }; H.H.A = function (N, W, R) {\n      const V = N.length; const n = H.H.m; const A = n.r; for (let l = 0; l < V; l += 2) {\n        if (N[l + 1] != 0) {\n          const M = l >> 1; const I = N[l + 1]; const e = M << 4 | I; const b = W - I; let Z = N[l] << b; const m = Z + (1 << b);\n          while (Z != m) { const J = A[Z] >>> 15 - W; R[J] = e; Z++; }\n        }\n      }\n    }; H.H.l = function (N, W) {\n      const R = H.H.m.r; const V = 15 - W; for (let n = 0; n < N.length;\n        n += 2) { const A = N[n] << W - N[n + 1]; N[n] = R[A] >>> V; }\n    }; H.H.M = function (N, W, R) { R <<= (W & 7); const V = W >>> 3; N[V] |= R; N[V + 1] |= R >>> 8; };\n    H.H.I = function (N, W, R) { R <<= (W & 7); const V = W >>> 3; N[V] |= R; N[V + 1] |= R >>> 8; N[V + 2] |= R >>> 16; }; H.H.e = function (N, W, R) { return (N[W >>> 3] | N[(W >>> 3) + 1] << 8) >>> (W & 7) & (1 << R) - 1; };\n    H.H.b = function (N, W, R) { return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7) & (1 << R) - 1; }; H.H.Z = function (N, W) { return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16) >>> (W & 7); };\n    H.H.i = function (N, W) { return (N[W >>> 3] | N[(W >>> 3) + 1] << 8 | N[(W >>> 3) + 2] << 16 | N[(W >>> 3) + 3] << 24) >>> (W & 7); }; H.H.m = (function () {\n      const N = Uint16Array; const W = Uint32Array;\n      return {\n        K: new N(16), j: new N(16), X: [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], S: [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 999, 999, 999], T: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0], q: new N(32), p: [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 65535, 65535], z: [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0], c: new W(32), J: new N(512), _: [], h: new N(32), $: [], w: new N(32768), C: [], v: [], d: new N(32768), D: [], u: new N(512), Q: [], r: new N(1 << 15), s: new W(286), Y: new W(30), a: new W(19), t: new W(15e3), k: new N(1 << 16), g: new N(1 << 15),\n      };\n    }());\n    (function () {\n      const N = H.H.m; const W = 1 << 15; for (var R = 0; R < W; R++) {\n        let V = R; V = (V & 2863311530) >>> 1 | (V & 1431655765) << 1;\n        V = (V & 3435973836) >>> 2 | (V & 858993459) << 2; V = (V & 4042322160) >>> 4 | (V & 252645135) << 4; V = (V & 4278255360) >>> 8 | (V & 16711935) << 8;\n        N.r[R] = (V >>> 16 | V << 16) >>> 17;\n      } function n(A, l, M) { while (l-- != 0)A.push(0, M); } for (var R = 0; R < 32; R++) {\n        N.q[R] = N.S[R] << 3 | N.T[R];\n        N.c[R] = N.p[R] << 4 | N.z[R];\n      }n(N._, 144, 8); n(N._, 255 - 143, 9); n(N._, 279 - 255, 7); n(N._, 287 - 279, 8); H.H.n(N._, 9);\n      H.H.A(N._, 9, N.J); H.H.l(N._, 9); n(N.$, 32, 5); H.H.n(N.$, 5); H.H.A(N.$, 5, N.h); H.H.l(N.$, 5); n(N.Q, 19, 0); n(N.C, 286, 0);\n      n(N.D, 30, 0); n(N.v, 320, 0);\n    }()); return H.H.N;\n  }());\n\n  function _readInterlace(data, out) {\n    const w = out.width; const\n      h = out.height;\n    const bpp = _getBPP(out); const cbpp = bpp >> 3; const\n      bpl = Math.ceil(w * bpp / 8);\n    const img = new Uint8Array(h * bpl);\n    let di = 0;\n\n    const starting_row = [0, 0, 4, 0, 2, 0, 1];\n    const starting_col = [0, 4, 0, 2, 0, 1, 0];\n    const row_increment = [8, 8, 8, 4, 4, 2, 2];\n    const col_increment = [8, 8, 4, 4, 2, 2, 1];\n\n    let pass = 0;\n    while (pass < 7) {\n      const ri = row_increment[pass]; const\n        ci = col_increment[pass];\n      let sw = 0; let\n        sh = 0;\n      let cr = starting_row[pass]; while (cr < h) { cr += ri; sh++; }\n      let cc = starting_col[pass]; while (cc < w) { cc += ci; sw++; }\n      const bpll = Math.ceil(sw * bpp / 8);\n      _filterZero(data, out, di, sw, sh);\n\n      let y = 0; let\n        row = starting_row[pass];\n      while (row < h) {\n        let col = starting_col[pass];\n        let cdi = (di + y * bpll) << 3;\n\n        while (col < w) {\n          if (bpp == 1) {\n            var val = data[cdi >> 3]; val = (val >> (7 - (cdi & 7))) & 1;\n            img[row * bpl + (col >> 3)] |= (val << (7 - ((col & 7) << 0)));\n          }\n          if (bpp == 2) {\n            var val = data[cdi >> 3]; val = (val >> (6 - (cdi & 7))) & 3;\n            img[row * bpl + (col >> 2)] |= (val << (6 - ((col & 3) << 1)));\n          }\n          if (bpp == 4) {\n            var val = data[cdi >> 3]; val = (val >> (4 - (cdi & 7))) & 15;\n            img[row * bpl + (col >> 1)] |= (val << (4 - ((col & 1) << 2)));\n          }\n          if (bpp >= 8) {\n            const ii = row * bpl + col * cbpp;\n            for (let j = 0; j < cbpp; j++) img[ii + j] = data[(cdi >> 3) + j];\n          }\n          cdi += bpp; col += ci;\n        }\n        y++; row += ri;\n      }\n      if (sw * sh != 0) di += sh * (1 + bpll);\n      pass += 1;\n    }\n    return img;\n  }\n\n  function _getBPP(out) {\n    const noc = [1, null, 3, 1, 2, null, 4][out.ctype];\n    return noc * out.depth;\n  }\n\n  function _filterZero(data, out, off, w, h) {\n    let bpp = _getBPP(out); const\n      bpl = Math.ceil(w * bpp / 8);\n    bpp = Math.ceil(bpp / 8);\n\n    let i; let di; let type = data[off]; let\n      x = 0;\n\n    if (type > 1) data[off] = [0, 0, 1][type - 2];\n    if (type == 3) for (x = bpp; x < bpl; x++) data[x + 1] = (data[x + 1] + (data[x + 1 - bpp] >>> 1)) & 255;\n\n    for (let y = 0; y < h; y++) {\n      i = off + y * bpl; di = i + y + 1;\n      type = data[di - 1]; x = 0;\n\n      if (type == 0) for (; x < bpl; x++) data[i + x] = data[di + x];\n      else if (type == 1) {\n        for (; x < bpp; x++) data[i + x] = data[di + x];\n\t\t\t\t\t\t\t   for (; x < bpl; x++) data[i + x] = (data[di + x] + data[i + x - bpp]);\n      } else if (type == 2) { for (; x < bpl; x++) data[i + x] = (data[di + x] + data[i + x - bpl]); } else if (type == 3) {\n        for (; x < bpp; x++) data[i + x] = (data[di + x] + (data[i + x - bpl] >>> 1));\n\t\t\t\t\t\t\t   for (; x < bpl; x++) data[i + x] = (data[di + x] + ((data[i + x - bpl] + data[i + x - bpp]) >>> 1));\n      } else {\n        for (; x < bpp; x++) data[i + x] = (data[di + x] + _paeth(0, data[i + x - bpl], 0));\n\t\t\t\t\t\t\t   for (; x < bpl; x++) data[i + x] = (data[di + x] + _paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl]));\n      }\n    }\n    return data;\n  }\n\n  function _paeth(a, b, c) {\n    const p = a + b - c; const pa = (p - a); const pb = (p - b); const\n      pc = (p - c);\n    if (pa * pa <= pb * pb && pa * pa <= pc * pc) return a;\n    if (pb * pb <= pc * pc) return b;\n    return c;\n  }\n\n  function _IHDR(data, offset, out) {\n    out.width = _bin.readUint(data, offset); offset += 4;\n    out.height = _bin.readUint(data, offset); offset += 4;\n    out.depth = data[offset]; offset++;\n    out.ctype = data[offset]; offset++;\n    out.compress = data[offset]; offset++;\n    out.filter = data[offset]; offset++;\n    out.interlace = data[offset]; offset++;\n  }\n\n  function _copyTile(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {\n    const w = Math.min(sw, tw); const\n      h = Math.min(sh, th);\n    let si = 0; let\n      ti = 0;\n    for (let y = 0; y < h; y++) {\n      for (let x = 0; x < w; x++) {\n        if (xoff >= 0 && yoff >= 0) { si = (y * sw + x) << 2; ti = ((yoff + y) * tw + xoff + x) << 2; } else { si = ((-yoff + y) * sw - xoff + x) << 2; ti = (y * tw + x) << 2; }\n\n        if (mode == 0) { tb[ti] = sb[si]; tb[ti + 1] = sb[si + 1]; tb[ti + 2] = sb[si + 2]; tb[ti + 3] = sb[si + 3]; } else if (mode == 1) {\n          var fa = sb[si + 3] * (1 / 255); var fr = sb[si] * fa; var fg = sb[si + 1] * fa; var\n            fb = sb[si + 2] * fa;\n          var ba = tb[ti + 3] * (1 / 255); var br = tb[ti] * ba; var bg = tb[ti + 1] * ba; var\n            bb = tb[ti + 2] * ba;\n\n          const ifa = 1 - fa; const oa = fa + ba * ifa; const\n            ioa = (oa == 0 ? 0 : 1 / oa);\n          tb[ti + 3] = 255 * oa;\n          tb[ti + 0] = (fr + br * ifa) * ioa;\n          tb[ti + 1] = (fg + bg * ifa) * ioa;\n          tb[ti + 2] = (fb + bb * ifa) * ioa;\n        } else if (mode == 2) {\t// copy only differences, otherwise zero\n          var fa = sb[si + 3]; var fr = sb[si]; var fg = sb[si + 1]; var\n            fb = sb[si + 2];\n          var ba = tb[ti + 3]; var br = tb[ti]; var bg = tb[ti + 1]; var\n            bb = tb[ti + 2];\n          if (fa == ba && fr == br && fg == bg && fb == bb) { tb[ti] = 0; tb[ti + 1] = 0; tb[ti + 2] = 0; tb[ti + 3] = 0; } else { tb[ti] = fr; tb[ti + 1] = fg; tb[ti + 2] = fb; tb[ti + 3] = fa; }\n        } else if (mode == 3) {\t// check if can be blended\n          var fa = sb[si + 3]; var fr = sb[si]; var fg = sb[si + 1]; var\n            fb = sb[si + 2];\n          var ba = tb[ti + 3]; var br = tb[ti]; var bg = tb[ti + 1]; var\n            bb = tb[ti + 2];\n          if (fa == ba && fr == br && fg == bg && fb == bb) continue;\n          // if(fa!=255 && ba!=0) return false;\n          if (fa < 220 && ba > 20) return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  return {\n    decode,\n    toRGBA8,\n    _paeth,\n    _copyTile,\n    _bin,\n  };\n}());\n\n(function () {\n  const { _copyTile } = UPNG;\n  const { _bin } = UPNG;\n  const paeth = UPNG._paeth;\n  var crcLib = {\n    table: (function () {\n\t\t   const tab = new Uint32Array(256);\n\t\t   for (let n = 0; n < 256; n++) {\n        let c = n;\n        for (let k = 0; k < 8; k++) {\n          if (c & 1) c = 0xedb88320 ^ (c >>> 1);\n          else c >>>= 1;\n        }\n        tab[n] = c;\n      }\n      return tab;\n    }()),\n    update(c, buf, off, len) {\n      for (let i = 0; i < len; i++) c = crcLib.table[(c ^ buf[off + i]) & 0xff] ^ (c >>> 8);\n      return c;\n    },\n    crc(b, o, l) { return crcLib.update(0xffffffff, b, o, l) ^ 0xffffffff; },\n  };\n\n  function addErr(er, tg, ti, f) {\n    tg[ti] += (er[0] * f) >> 4; tg[ti + 1] += (er[1] * f) >> 4; tg[ti + 2] += (er[2] * f) >> 4; tg[ti + 3] += (er[3] * f) >> 4;\n  }\n  function N(x) { return Math.max(0, Math.min(255, x)); }\n  function D(a, b) {\n    const dr = a[0] - b[0]; const dg = a[1] - b[1]; const db = a[2] - b[2]; const\n      da = a[3] - b[3]; return (dr * dr + dg * dg + db * db + da * da);\n  }\n\n  // MTD: 0: None, 1: floyd-steinberg, 2: Bayer\n  function dither(sb, w, h, plte, tb, oind, MTD) {\n    if (MTD == null) MTD = 1;\n\n    const pc = plte.length; const nplt = []; const\n      rads = [];\n    for (var i = 0; i < pc; i++) {\n      const c = plte[i];\n      nplt.push([((c >>> 0) & 255), ((c >>> 8) & 255), ((c >>> 16) & 255), ((c >>> 24) & 255)]);\n    }\n    for (var i = 0; i < pc; i++) {\n      let ne = 0xffffffff; var\n        ni = 0;\n      for (var j = 0; j < pc; j++) { var ce = D(nplt[i], nplt[j]); if (j != i && ce < ne) { ne = ce; ni = j; } }\n      const hd = Math.sqrt(ne) / 2;\n      rads[i] = ~~(hd * hd);\n    }\n\n    const tb32 = new Uint32Array(tb.buffer);\n    const err = new Int16Array(w * h * 4);\n\n    /*\n\t\tvar S=2, M = [\n\t\t\t0,2,\n\t\t    3,1];  // */\n    //*\n    const S = 4; const\n      M = [\n\t\t\t 0, 8, 2, 10,\n\t\t    12, 4, 14, 6,\n\t\t\t 3, 11, 1, 9,\n        15, 7, 13, 5]; //* /\n    for (var i = 0; i < M.length; i++) M[i] = 255 * (-0.5 + (M[i] + 0.5) / (S * S));\n\n    for (let y = 0; y < h; y++) {\n      for (let x = 0; x < w; x++) {\n        var i = (y * w + x) * 4;\n\n        var cc;\n        if (MTD != 2) cc = [N(sb[i] + err[i]), N(sb[i + 1] + err[i + 1]), N(sb[i + 2] + err[i + 2]), N(sb[i + 3] + err[i + 3])];\n        else {\n          var ce = M[(y & (S - 1)) * S + (x & (S - 1))];\n          cc = [N(sb[i] + ce), N(sb[i + 1] + ce), N(sb[i + 2] + ce), N(sb[i + 3] + ce)];\n        }\n\n        var ni = 0; let\n          nd = 0xffffff;\n        for (var j = 0; j < pc; j++) {\n          const cd = D(cc, nplt[j]);\n          if (cd < nd) { nd = cd; ni = j; }\n        }\n\n        const nc = nplt[ni];\n        const er = [cc[0] - nc[0], cc[1] - nc[1], cc[2] - nc[2], cc[3] - nc[3]];\n\n        if (MTD == 1) {\n          // addErr(er, err, i+4, 16);\n          if (x != w - 1) addErr(er, err, i + 4, 7);\n          if (y != h - 1) {\n            if (x != 0) addErr(er, err, i + 4 * w - 4, 3);\n\t\t\t\t\t\t\t\t   addErr(er, err, i + 4 * w, 5);\n            if (x != w - 1) addErr(er, err, i + 4 * w + 4, 1);\n          }//* /\n        }\n        oind[i >> 2] = ni; tb32[i >> 2] = plte[ni];\n      }\n    }\n  }\n\n  function encode(bufs, w, h, ps, dels, tabs, forbidPlte) {\n    if (ps == null) ps = 0;\n    if (forbidPlte == null) forbidPlte = false;\n\n    const nimg = compress(bufs, w, h, ps, [false, false, false, 0, forbidPlte, false]);\n    compressPNG(nimg, -1);\n\n    return _main(nimg, w, h, dels, tabs);\n  }\n\n  function encodeLL(bufs, w, h, cc, ac, depth, dels, tabs) {\n    const nimg = { ctype: 0 + (cc == 1 ? 0 : 2) + (ac == 0 ? 0 : 4), depth, frames: [] };\n\n    const time = Date.now();\n    const bipp = (cc + ac) * depth; const\n      bipl = bipp * w;\n    for (let i = 0; i < bufs.length; i++) {\n      nimg.frames.push({\n        rect: {\n          x: 0, y: 0, width: w, height: h,\n        },\n        img: new Uint8Array(bufs[i]),\n        blend: 0,\n        dispose: 1,\n        bpp: Math.ceil(bipp / 8),\n        bpl: Math.ceil(bipl / 8),\n      });\n    }\n\n    compressPNG(nimg, 0, true);\n\n    const out = _main(nimg, w, h, dels, tabs);\n    return out;\n  }\n\n  function _main(nimg, w, h, dels, tabs) {\n    if (tabs == null) tabs = {};\n    const { crc } = crcLib;\n    const wUi = _bin.writeUint;\n    const wUs = _bin.writeUshort;\n    const wAs = _bin.writeASCII;\n    let offset = 8; const anim = nimg.frames.length > 1; let\n      pltAlpha = false;\n\n    let cicc;\n\n    let leng = 8 + (16 + 5 + 4) /* + (9+4) */ + (anim ? 20 : 0);\n    if (tabs.sRGB != null) leng += 8 + 1 + 4;\n    if (tabs.pHYs != null) leng += 8 + 9 + 4;\n    if (tabs.iCCP != null) { cicc = pako.deflate(tabs.iCCP); leng += 8 + 11 + 2 + cicc.length + 4; }\n    if (nimg.ctype == 3) {\n      var dl = nimg.plte.length;\n      for (var i = 0; i < dl; i++) if ((nimg.plte[i] >>> 24) != 255) pltAlpha = true;\n      leng += (8 + dl * 3 + 4) + (pltAlpha ? (8 + dl * 1 + 4) : 0);\n    }\n    for (var j = 0; j < nimg.frames.length; j++) {\n      var fr = nimg.frames[j];\n      if (anim) leng += 38;\n      leng += fr.cimg.length + 12;\n      if (j != 0) leng += 4;\n    }\n    leng += 12;\n\n    const data = new Uint8Array(leng);\n    const wr = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n    for (var i = 0; i < 8; i++) data[i] = wr[i];\n\n    wUi(data, offset, 13); offset += 4;\n    wAs(data, offset, 'IHDR'); offset += 4;\n    wUi(data, offset, w); offset += 4;\n    wUi(data, offset, h); offset += 4;\n    data[offset] = nimg.depth; offset++; // depth\n    data[offset] = nimg.ctype; offset++; // ctype\n    data[offset] = 0; offset++; // compress\n    data[offset] = 0; offset++; // filter\n    data[offset] = 0; offset++; // interlace\n    wUi(data, offset, crc(data, offset - 17, 17)); offset += 4; // crc\n\n    // 13 bytes to say, that it is sRGB\n    if (tabs.sRGB != null) {\n      wUi(data, offset, 1); offset += 4;\n      wAs(data, offset, 'sRGB'); offset += 4;\n      data[offset] = tabs.sRGB; offset++;\n      wUi(data, offset, crc(data, offset - 5, 5)); offset += 4; // crc\n    }\n    if (tabs.iCCP != null) {\n      const sl = 11 + 2 + cicc.length;\n      wUi(data, offset, sl); offset += 4;\n      wAs(data, offset, 'iCCP'); offset += 4;\n      wAs(data, offset, 'ICC profile'); offset += 11; offset += 2;\n      data.set(cicc, offset); offset += cicc.length;\n      wUi(data, offset, crc(data, offset - (sl + 4), sl + 4)); offset += 4; // crc\n    }\n    if (tabs.pHYs != null) {\n      wUi(data, offset, 9); offset += 4;\n      wAs(data, offset, 'pHYs'); offset += 4;\n      wUi(data, offset, tabs.pHYs[0]); offset += 4;\n      wUi(data, offset, tabs.pHYs[1]); offset += 4;\n      data[offset] = tabs.pHYs[2];\t\t\toffset++;\n      wUi(data, offset, crc(data, offset - 13, 13)); offset += 4; // crc\n    }\n\n    if (anim) {\n      wUi(data, offset, 8); offset += 4;\n      wAs(data, offset, 'acTL'); offset += 4;\n      wUi(data, offset, nimg.frames.length); offset += 4;\n      wUi(data, offset, tabs.loop != null ? tabs.loop : 0); offset += 4;\n      wUi(data, offset, crc(data, offset - 12, 12)); offset += 4; // crc\n    }\n\n    if (nimg.ctype == 3) {\n      var dl = nimg.plte.length;\n      wUi(data, offset, dl * 3); offset += 4;\n      wAs(data, offset, 'PLTE'); offset += 4;\n      for (var i = 0; i < dl; i++) {\n        const ti = i * 3; const c = nimg.plte[i]; const r = (c) & 255; const g = (c >>> 8) & 255; const\n          b = (c >>> 16) & 255;\n        data[offset + ti + 0] = r; data[offset + ti + 1] = g; data[offset + ti + 2] = b;\n      }\n      offset += dl * 3;\n      wUi(data, offset, crc(data, offset - dl * 3 - 4, dl * 3 + 4)); offset += 4; // crc\n\n      if (pltAlpha) {\n        wUi(data, offset, dl); offset += 4;\n        wAs(data, offset, 'tRNS'); offset += 4;\n        for (var i = 0; i < dl; i++) data[offset + i] = (nimg.plte[i] >>> 24) & 255;\n        offset += dl;\n        wUi(data, offset, crc(data, offset - dl - 4, dl + 4)); offset += 4; // crc\n      }\n    }\n\n    let fi = 0;\n    for (var j = 0; j < nimg.frames.length; j++) {\n      var fr = nimg.frames[j];\n      if (anim) {\n        wUi(data, offset, 26); offset += 4;\n        wAs(data, offset, 'fcTL'); offset += 4;\n        wUi(data, offset, fi++); offset += 4;\n        wUi(data, offset, fr.rect.width); offset += 4;\n        wUi(data, offset, fr.rect.height); offset += 4;\n        wUi(data, offset, fr.rect.x); offset += 4;\n        wUi(data, offset, fr.rect.y); offset += 4;\n        wUs(data, offset, dels[j]); offset += 2;\n        wUs(data, offset, 1000); offset += 2;\n        data[offset] = fr.dispose; offset++;\t// dispose\n        data[offset] = fr.blend; offset++;\t// blend\n        wUi(data, offset, crc(data, offset - 30, 30)); offset += 4; // crc\n      }\n\n      const imgd = fr.cimg; var\n        dl = imgd.length;\n      wUi(data, offset, dl + (j == 0 ? 0 : 4)); offset += 4;\n      const ioff = offset;\n      wAs(data, offset, (j == 0) ? 'IDAT' : 'fdAT'); offset += 4;\n      if (j != 0) { wUi(data, offset, fi++); offset += 4; }\n      data.set(imgd, offset);\n      offset += dl;\n      wUi(data, offset, crc(data, ioff, offset - ioff)); offset += 4; // crc\n    }\n\n    wUi(data, offset, 0); offset += 4;\n    wAs(data, offset, 'IEND'); offset += 4;\n    wUi(data, offset, crc(data, offset - 4, 4)); offset += 4; // crc\n\n    return data.buffer;\n  }\n\n  function compressPNG(out, filter, levelZero) {\n    for (let i = 0; i < out.frames.length; i++) {\n      const frm = out.frames[i]; const nw = frm.rect.width; const\n        nh = frm.rect.height;\n      const fdata = new Uint8Array(nh * frm.bpl + nh);\n      frm.cimg = _filterZero(frm.img, nh, frm.bpp, frm.bpl, fdata, filter, levelZero);\n    }\n  }\n\n  function compress(bufs, w, h, ps, prms) // prms:  onlyBlend, minBits, forbidPlte\n  {\n    // var time = Date.now();\n    const onlyBlend = prms[0]; const evenCrd = prms[1]; const forbidPrev = prms[2]; const minBits = prms[3]; const forbidPlte = prms[4]; const\n      dith = prms[5];\n\n    let ctype = 6; let depth = 8; let\n      alphaAnd = 255;\n\n    for (var j = 0; j < bufs.length; j++) { // when not quantized, other frames can contain colors, that are not in an initial frame\n      const img = new Uint8Array(bufs[j]); var\n        ilen = img.length;\n      for (var i = 0; i < ilen; i += 4) alphaAnd &= img[i + 3];\n    }\n    const gotAlpha = (alphaAnd != 255);\n\n    // console.log(\"alpha check\", Date.now()-time);  time = Date.now();\n\n    // var brute = gotAlpha && forGIF;\t\t// brute : frames can only be copied, not \"blended\"\n    const frms = framize(bufs, w, h, onlyBlend, evenCrd, forbidPrev);\n    // console.log(\"framize\", Date.now()-time);  time = Date.now();\n\n    const cmap = {}; const plte = []; const\n      inds = [];\n\n    if (ps != 0) {\n      const nbufs = []; for (var i = 0; i < frms.length; i++) nbufs.push(frms[i].img.buffer);\n\n      const abuf = concatRGBA(nbufs); const\n        qres = quantize(abuf, ps);\n\n      for (var i = 0; i < qres.plte.length; i++) plte.push(qres.plte[i].est.rgba);\n\n      let cof = 0;\n      for (var i = 0; i < frms.length; i++) {\n        var frm = frms[i]; const bln = frm.img.length; var\n          ind = new Uint8Array(qres.inds.buffer, cof >> 2, bln >> 2); inds.push(ind);\n        const bb = new Uint8Array(qres.abuf, cof, bln);\n\n        // console.log(frm.img, frm.width, frm.height);\n        // var time = Date.now();\n        if (dith) dither(frm.img, frm.rect.width, frm.rect.height, plte, bb, ind);\n        // console.log(Date.now()-time);\n        frm.img.set(bb); cof += bln;\n      }\n\n      // console.log(\"quantize\", Date.now()-time);  time = Date.now();\n    } else {\n      // what if ps==0, but there are <=256 colors?  we still need to detect, if the palette could be used\n      for (var j = 0; j < frms.length; j++) { // when not quantized, other frames can contain colors, that are not in an initial frame\n        var frm = frms[j]; const img32 = new Uint32Array(frm.img.buffer); var nw = frm.rect.width; var\n          ilen = img32.length;\n        var ind = new Uint8Array(ilen); inds.push(ind);\n        for (var i = 0; i < ilen; i++) {\n          const c = img32[i];\n          if (i != 0 && c == img32[i - 1]) ind[i] = ind[i - 1];\n          else if (i > nw && c == img32[i - nw]) ind[i] = ind[i - nw];\n          else {\n            let cmc = cmap[c];\n            if (cmc == null) { cmap[c] = cmc = plte.length; plte.push(c); if (plte.length >= 300) break; }\n            ind[i] = cmc;\n          }\n        }\n      }\n      // console.log(\"make palette\", Date.now()-time);  time = Date.now();\n    }\n\n    const cc = plte.length; // console.log(\"colors:\",cc);\n    if (cc <= 256 && forbidPlte == false) {\n      if (cc <= 2) depth = 1; else if (cc <= 4) depth = 2; else if (cc <= 16) depth = 4; else depth = 8;\n      depth = Math.max(depth, minBits);\n    }\n\n    for (var j = 0; j < frms.length; j++) {\n      var frm = frms[j]; const nx = frm.rect.x; const ny = frm.rect.y; var nw = frm.rect.width; const\n        nh = frm.rect.height;\n      let cimg = frm.img; const\n        cimg32 = new Uint32Array(cimg.buffer);\n      let bpl = 4 * nw; let\n        bpp = 4;\n      if (cc <= 256 && forbidPlte == false) {\n        bpl = Math.ceil(depth * nw / 8);\n        var nimg = new Uint8Array(bpl * nh);\n        const inj = inds[j];\n        for (let y = 0; y < nh; y++) {\n          var i = y * bpl; const\n            ii = y * nw;\n          if (depth == 8) for (var x = 0; x < nw; x++) nimg[i + (x)] = (inj[ii + x]);\n          else if (depth == 4) for (var x = 0; x < nw; x++) nimg[i + (x >> 1)] |= (inj[ii + x] << (4 - (x & 1) * 4));\n          else if (depth == 2) for (var x = 0; x < nw; x++) nimg[i + (x >> 2)] |= (inj[ii + x] << (6 - (x & 3) * 2));\n          else if (depth == 1) for (var x = 0; x < nw; x++) nimg[i + (x >> 3)] |= (inj[ii + x] << (7 - (x & 7) * 1));\n        }\n        cimg = nimg; ctype = 3; bpp = 1;\n      } else if (gotAlpha == false && frms.length == 1) {\t// some next \"reduced\" frames may contain alpha for blending\n        var nimg = new Uint8Array(nw * nh * 3); const\n          area = nw * nh;\n        for (var i = 0; i < area; i++) {\n          const ti = i * 3; const\n            qi = i * 4; nimg[ti] = cimg[qi]; nimg[ti + 1] = cimg[qi + 1]; nimg[ti + 2] = cimg[qi + 2];\n        }\n        cimg = nimg; ctype = 2; bpp = 3; bpl = 3 * nw;\n      }\n      frm.img = cimg; frm.bpl = bpl; frm.bpp = bpp;\n    }\n    // console.log(\"colors => palette indices\", Date.now()-time);  time = Date.now();\n\n    return {\n      ctype, depth, plte, frames: frms,\n    };\n  }\n  function framize(bufs, w, h, alwaysBlend, evenCrd, forbidPrev) {\n    /*  DISPOSE\n\t\t\t- 0 : no change\n\t\t\t- 1 : clear to transparent\n\t\t\t- 2 : retstore to content before rendering (previous frame disposed)\n\t\t\tBLEND\n\t\t\t- 0 : replace\n\t\t\t- 1 : blend\n\t\t*/\n    const frms = [];\n    for (var j = 0; j < bufs.length; j++) {\n      const cimg = new Uint8Array(bufs[j]); const\n        cimg32 = new Uint32Array(cimg.buffer);\n      var nimg;\n\n      let nx = 0; let ny = 0; let nw = w; let nh = h; let\n        blend = alwaysBlend ? 1 : 0;\n      if (j != 0) {\n        const tlim = (forbidPrev || alwaysBlend || j == 1 || frms[j - 2].dispose != 0) ? 1 : 2; let tstp = 0; let\n          tarea = 1e9;\n        for (let it = 0; it < tlim; it++) {\n          var pimg = new Uint8Array(bufs[j - 1 - it]); const\n            p32 = new Uint32Array(bufs[j - 1 - it]);\n          let mix = w; let miy = h; let max = -1; let may = -1;\n          for (let y = 0; y < h; y++) {\n            for (let x = 0; x < w; x++) {\n              var i = y * w + x;\n              if (cimg32[i] != p32[i]) {\n                if (x < mix) mix = x; if (x > max) max = x;\n                if (y < miy) miy = y; if (y > may) may = y;\n              }\n            }\n          }\n          if (max == -1) mix = miy = max = may = 0;\n          if (evenCrd) { if ((mix & 1) == 1)mix--; if ((miy & 1) == 1)miy--; }\n          const sarea = (max - mix + 1) * (may - miy + 1);\n          if (sarea < tarea) {\n            tarea = sarea; tstp = it;\n            nx = mix; ny = miy; nw = max - mix + 1; nh = may - miy + 1;\n          }\n        }\n\n        // alwaysBlend: pokud zjistím, že blendit nelze, nastavím předchozímu snímku dispose=1. Zajistím, aby obsahoval můj obdélník.\n        var pimg = new Uint8Array(bufs[j - 1 - tstp]);\n        if (tstp == 1) frms[j - 1].dispose = 2;\n\n        nimg = new Uint8Array(nw * nh * 4);\n        _copyTile(pimg, w, h, nimg, nw, nh, -nx, -ny, 0);\n\n        blend = _copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 3) ? 1 : 0;\n        if (blend == 1) {\n          _prepareDiff(cimg, w, h, nimg, {\n            x: nx, y: ny, width: nw, height: nh,\n          });\n        } else _copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 0);\n      } else nimg = cimg.slice(0);\t// img may be rewritten further ... don't rewrite input\n\n      frms.push({\n        rect: {\n          x: nx, y: ny, width: nw, height: nh,\n        },\n        img: nimg,\n        blend,\n        dispose: 0,\n      });\n    }\n\n    if (alwaysBlend) {\n      for (var j = 0; j < frms.length; j++) {\n        var frm = frms[j]; if (frm.blend == 1) continue;\n        const r0 = frm.rect; const\n          r1 = frms[j - 1].rect;\n        const miX = Math.min(r0.x, r1.x); const\n          miY = Math.min(r0.y, r1.y);\n        const maX = Math.max(r0.x + r0.width, r1.x + r1.width); const\n          maY = Math.max(r0.y + r0.height, r1.y + r1.height);\n        const r = {\n          x: miX, y: miY, width: maX - miX, height: maY - miY,\n        };\n\n        frms[j - 1].dispose = 1;\n        if (j - 1 != 0) _updateFrame(bufs, w, h, frms, j - 1, r, evenCrd);\n        _updateFrame(bufs, w, h, frms, j, r, evenCrd);\n      }\n    }\n    let area = 0;\n    if (bufs.length != 1) {\n      for (var i = 0; i < frms.length; i++) {\n        var frm = frms[i];\n        area += frm.rect.width * frm.rect.height;\n      // if(i==0 || frm.blend!=1) continue;\n      // var ob = new Uint8Array(\n      // console.log(frm.blend, frm.dispose, frm.rect);\n      }\n    }\n    // if(area!=0) console.log(area);\n    return frms;\n  }\n  function _updateFrame(bufs, w, h, frms, i, r, evenCrd) {\n    const U8 = Uint8Array; const\n      U32 = Uint32Array;\n    const pimg = new U8(bufs[i - 1]); const pimg32 = new U32(bufs[i - 1]); const\n      nimg = i + 1 < bufs.length ? new U8(bufs[i + 1]) : null;\n    const cimg = new U8(bufs[i]); const\n      cimg32 = new U32(cimg.buffer);\n\n    let mix = w; let miy = h; let max = -1; let may = -1;\n    for (let y = 0; y < r.height; y++) {\n      for (let x = 0; x < r.width; x++) {\n        const cx = r.x + x; const\n          cy = r.y + y;\n        const j = cy * w + cx; const\n          cc = cimg32[j];\n        // no need to draw transparency, or to dispose it. Or, if writing the same color and the next one does not need transparency.\n        if (cc == 0 || (frms[i - 1].dispose == 0 && pimg32[j] == cc && (nimg == null || nimg[j * 4 + 3] != 0))/**/) {} else {\n          if (cx < mix) mix = cx; if (cx > max) max = cx;\n          if (cy < miy) miy = cy; if (cy > may) may = cy;\n        }\n      }\n    }\n    if (max == -1) mix = miy = max = may = 0;\n    if (evenCrd) { if ((mix & 1) == 1)mix--; if ((miy & 1) == 1)miy--; }\n    r = {\n      x: mix, y: miy, width: max - mix + 1, height: may - miy + 1,\n    };\n\n    const fr = frms[i]; fr.rect = r; fr.blend = 1; fr.img = new Uint8Array(r.width * r.height * 4);\n    if (frms[i - 1].dispose == 0) {\n      _copyTile(pimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);\n      _prepareDiff(cimg, w, h, fr.img, r);\n    } else _copyTile(cimg, w, h, fr.img, r.width, r.height, -r.x, -r.y, 0);\n  }\n  function _prepareDiff(cimg, w, h, nimg, rec) {\n    _copyTile(cimg, w, h, nimg, rec.width, rec.height, -rec.x, -rec.y, 2);\n  }\n\n  function _filterZero(img, h, bpp, bpl, data, filter, levelZero) {\n    const fls = []; let\n      ftry = [0, 1, 2, 3, 4];\n    if (filter != -1) ftry = [filter];\n    else if (h * bpl > 500000 || bpp == 1) ftry = [0];\n    let opts; if (levelZero) opts = { level: 0 };\n\n    const CMPR = UZIP;\n\n    const time = Date.now();\n    for (var i = 0; i < ftry.length; i++) {\n      for (let y = 0; y < h; y++) _filterLine(data, img, y, bpl, bpp, ftry[i]);\n      // var nimg = new Uint8Array(data.length);\n      // var sz = UZIP.F.deflate(data, nimg);  fls.push(nimg.slice(0,sz));\n      // var dfl = pako[\"deflate\"](data), dl=dfl.length-4;\n      // var crc = (dfl[dl+3]<<24)|(dfl[dl+2]<<16)|(dfl[dl+1]<<8)|(dfl[dl+0]<<0);\n      // console.log(crc, UZIP.adler(data,2,data.length-6));\n      fls.push(CMPR.deflate(data, opts));\n    }\n\n    let ti; let\n      tsize = 1e9;\n    for (var i = 0; i < fls.length; i++) if (fls[i].length < tsize) { ti = i; tsize = fls[i].length; }\n    return fls[ti];\n  }\n  function _filterLine(data, img, y, bpl, bpp, type) {\n    const i = y * bpl; let\n      di = i + y;\n    data[di] = type; di++;\n\n    if (type == 0) {\n      if (bpl < 500) for (var x = 0; x < bpl; x++) data[di + x] = img[i + x];\n      else data.set(new Uint8Array(img.buffer, i, bpl), di);\n    } else if (type == 1) {\n      for (var x = 0; x < bpp; x++) data[di + x] = img[i + x];\n      for (var x = bpp; x < bpl; x++) data[di + x] = (img[i + x] - img[i + x - bpp] + 256) & 255;\n    } else if (y == 0) {\n      for (var x = 0; x < bpp; x++) data[di + x] = img[i + x];\n\n      if (type == 2) for (var x = bpp; x < bpl; x++) data[di + x] = img[i + x];\n      if (type == 3) for (var x = bpp; x < bpl; x++) data[di + x] = (img[i + x] - (img[i + x - bpp] >> 1) + 256) & 255;\n      if (type == 4) for (var x = bpp; x < bpl; x++) data[di + x] = (img[i + x] - paeth(img[i + x - bpp], 0, 0) + 256) & 255;\n    } else {\n      if (type == 2) { for (var x = 0; x < bpl; x++) data[di + x] = (img[i + x] + 256 - img[i + x - bpl]) & 255; }\n      if (type == 3) {\n        for (var x = 0; x < bpp; x++) data[di + x] = (img[i + x] + 256 - (img[i + x - bpl] >> 1)) & 255;\n\t\t\t\t\t\t  for (var x = bpp; x < bpl; x++) data[di + x] = (img[i + x] + 256 - ((img[i + x - bpl] + img[i + x - bpp]) >> 1)) & 255;\n      }\n      if (type == 4) {\n        for (var x = 0; x < bpp; x++) data[di + x] = (img[i + x] + 256 - paeth(0, img[i + x - bpl], 0)) & 255;\n\t\t\t\t\t\t  for (var x = bpp; x < bpl; x++) data[di + x] = (img[i + x] + 256 - paeth(img[i + x - bpp], img[i + x - bpl], img[i + x - bpp - bpl])) & 255;\n      }\n    }\n  }\n\n  function quantize(abuf, ps) {\n    const sb = new Uint8Array(abuf); const tb = sb.slice(0); const\n      tb32 = new Uint32Array(tb.buffer);\n\n    const KD = getKDtree(tb, ps);\n    const root = KD[0]; const\n      leafs = KD[1];\n\n    const len = sb.length;\n\n    const inds = new Uint8Array(len >> 2); let\n      nd;\n    if (sb.length < 20e6) // precise, but slow :(\n    {\n      for (var i = 0; i < len; i += 4) {\n        var r = sb[i] * (1 / 255); var g = sb[i + 1] * (1 / 255); var b = sb[i + 2] * (1 / 255); var\n          a = sb[i + 3] * (1 / 255);\n\n        nd = getNearest(root, r, g, b, a);\n        inds[i >> 2] = nd.ind; tb32[i >> 2] = nd.est.rgba;\n      }\n    } else {\n      for (var i = 0; i < len; i += 4) {\n        var r = sb[i] * (1 / 255); var g = sb[i + 1] * (1 / 255); var b = sb[i + 2] * (1 / 255); var\n          a = sb[i + 3] * (1 / 255);\n\n        nd = root; while (nd.left) nd = (planeDst(nd.est, r, g, b, a) <= 0) ? nd.left : nd.right;\n        inds[i >> 2] = nd.ind; tb32[i >> 2] = nd.est.rgba;\n      }\n    }\n    return { abuf: tb.buffer, inds, plte: leafs };\n  }\n\n  function getKDtree(nimg, ps, err) {\n    if (err == null) err = 0.0001;\n    const nimg32 = new Uint32Array(nimg.buffer);\n\n    const root = {\n      i0: 0, i1: nimg.length, bst: null, est: null, tdst: 0, left: null, right: null,\n    }; // basic statistic, extra statistic\n    root.bst = stats(nimg, root.i0, root.i1); root.est = estats(root.bst);\n    const leafs = [root];\n\n    while (leafs.length < ps) {\n      let maxL = 0; let\n        mi = 0;\n      for (var i = 0; i < leafs.length; i++) if (leafs[i].est.L > maxL) { maxL = leafs[i].est.L; mi = i; }\n      if (maxL < err) break;\n      const node = leafs[mi];\n\n      const s0 = splitPixels(nimg, nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);\n      const s0wrong = (node.i0 >= s0 || node.i1 <= s0);\n      // console.log(maxL, leafs.length, mi);\n      if (s0wrong) { node.est.L = 0; continue; }\n\n      const ln = {\n        i0: node.i0, i1: s0, bst: null, est: null, tdst: 0, left: null, right: null,\n      }; ln.bst = stats(nimg, ln.i0, ln.i1);\n      ln.est = estats(ln.bst);\n      const rn = {\n        i0: s0, i1: node.i1, bst: null, est: null, tdst: 0, left: null, right: null,\n      }; rn.bst = { R: [], m: [], N: node.bst.N - ln.bst.N };\n      for (var i = 0; i < 16; i++) rn.bst.R[i] = node.bst.R[i] - ln.bst.R[i];\n      for (var i = 0; i < 4; i++) rn.bst.m[i] = node.bst.m[i] - ln.bst.m[i];\n      rn.est = estats(rn.bst);\n\n      node.left = ln; node.right = rn;\n      leafs[mi] = ln; leafs.push(rn);\n    }\n    leafs.sort((a, b) => b.bst.N - a.bst.N);\n    for (var i = 0; i < leafs.length; i++) leafs[i].ind = i;\n    return [root, leafs];\n  }\n\n  function getNearest(nd, r, g, b, a) {\n    if (nd.left == null) { nd.tdst = dist(nd.est.q, r, g, b, a); return nd; }\n    const pd = planeDst(nd.est, r, g, b, a);\n\n    let node0 = nd.left; let\n      node1 = nd.right;\n    if (pd > 0) { node0 = nd.right; node1 = nd.left; }\n\n    const ln = getNearest(node0, r, g, b, a);\n    if (ln.tdst <= pd * pd) return ln;\n    const rn = getNearest(node1, r, g, b, a);\n    return rn.tdst < ln.tdst ? rn : ln;\n  }\n  function planeDst(est, r, g, b, a) { const { e } = est; return e[0] * r + e[1] * g + e[2] * b + e[3] * a - est.eMq; }\n  function dist(q, r, g, b, a) {\n    const d0 = r - q[0]; const d1 = g - q[1]; const d2 = b - q[2]; const\n      d3 = a - q[3]; return d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;\n  }\n\n  function splitPixels(nimg, nimg32, i0, i1, e, eMq) {\n    i1 -= 4;\n    const shfs = 0;\n    while (i0 < i1) {\n      while (vecDot(nimg, i0, e) <= eMq) i0 += 4;\n      while (vecDot(nimg, i1, e) > eMq) i1 -= 4;\n      if (i0 >= i1) break;\n\n      const t = nimg32[i0 >> 2]; nimg32[i0 >> 2] = nimg32[i1 >> 2]; nimg32[i1 >> 2] = t;\n\n      i0 += 4; i1 -= 4;\n    }\n    while (vecDot(nimg, i0, e) > eMq) i0 -= 4;\n    return i0 + 4;\n  }\n  function vecDot(nimg, i, e) {\n    return nimg[i] * e[0] + nimg[i + 1] * e[1] + nimg[i + 2] * e[2] + nimg[i + 3] * e[3];\n  }\n  function stats(nimg, i0, i1) {\n    const R = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    const m = [0, 0, 0, 0];\n    const N = (i1 - i0) >> 2;\n    for (let i = i0; i < i1; i += 4) {\n      const r = nimg[i] * (1 / 255); const g = nimg[i + 1] * (1 / 255); const b = nimg[i + 2] * (1 / 255); const\n        a = nimg[i + 3] * (1 / 255);\n      // var r = nimg[i], g = nimg[i+1], b = nimg[i+2], a = nimg[i+3];\n      m[0] += r; m[1] += g; m[2] += b; m[3] += a;\n\n      R[0] += r * r; R[1] += r * g; R[2] += r * b; R[3] += r * a;\n\t\t\t\t\t\t   R[5] += g * g; R[6] += g * b; R[7] += g * a;\n\t\t\t\t\t\t\t\t\t\t  R[10] += b * b; R[11] += b * a;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t R[15] += a * a;\n    }\n    R[4] = R[1]; R[8] = R[2]; R[9] = R[6]; R[12] = R[3]; R[13] = R[7]; R[14] = R[11];\n\n    return { R, m, N };\n  }\n  function estats(stats) {\n    const { R } = stats;\n    const { m } = stats;\n    const { N } = stats;\n\n    // when all samples are equal, but N is large (millions), the Rj can be non-zero ( 0.0003.... - precission error)\n    const m0 = m[0]; const m1 = m[1]; const m2 = m[2]; const m3 = m[3]; const\n      iN = (N == 0 ? 0 : 1 / N);\n    const Rj = [\n      R[0] - m0 * m0 * iN, R[1] - m0 * m1 * iN, R[2] - m0 * m2 * iN, R[3] - m0 * m3 * iN,\n      R[4] - m1 * m0 * iN, R[5] - m1 * m1 * iN, R[6] - m1 * m2 * iN, R[7] - m1 * m3 * iN,\n      R[8] - m2 * m0 * iN, R[9] - m2 * m1 * iN, R[10] - m2 * m2 * iN, R[11] - m2 * m3 * iN,\n      R[12] - m3 * m0 * iN, R[13] - m3 * m1 * iN, R[14] - m3 * m2 * iN, R[15] - m3 * m3 * iN,\n    ];\n\n    const A = Rj; const\n      M = M4;\n    let b = [Math.random(), Math.random(), Math.random(), Math.random()]; let mi = 0; let\n      tmi = 0;\n\n    if (N != 0) {\n      for (let i = 0; i < 16; i++) {\n        b = M.multVec(A, b); tmi = Math.sqrt(M.dot(b, b)); b = M.sml(1 / tmi, b);\n        if (i != 0 && Math.abs(tmi - mi) < 1e-9) break; mi = tmi;\n      }\n    }\n    // b = [0,0,1,0];  mi=N;\n    const q = [m0 * iN, m1 * iN, m2 * iN, m3 * iN];\n    const eMq255 = M.dot(M.sml(255, q), b);\n\n    return {\n      Cov: Rj,\n      q,\n      e: b,\n      L: mi,\n      eMq255,\n      eMq: M.dot(b, q),\n      rgba: (((Math.round(255 * q[3]) << 24) | (Math.round(255 * q[2]) << 16) | (Math.round(255 * q[1]) << 8) | (Math.round(255 * q[0]) << 0)) >>> 0),\n    };\n  }\n  var M4 = {\n    multVec(m, v) {\n      return [\n        m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * v[3],\n        m[4] * v[0] + m[5] * v[1] + m[6] * v[2] + m[7] * v[3],\n        m[8] * v[0] + m[9] * v[1] + m[10] * v[2] + m[11] * v[3],\n        m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15] * v[3],\n      ];\n    },\n    dot(x, y) { return x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3]; },\n    sml(a, y) { return [a * y[0], a * y[1], a * y[2], a * y[3]]; },\n  };\n\n  function concatRGBA(bufs) {\n    let tlen = 0;\n    for (var i = 0; i < bufs.length; i++) tlen += bufs[i].byteLength;\n    const nimg = new Uint8Array(tlen); let\n      noff = 0;\n    for (var i = 0; i < bufs.length; i++) {\n      const img = new Uint8Array(bufs[i]); const\n        il = img.length;\n      for (let j = 0; j < il; j += 4) {\n        let r = img[j]; let g = img[j + 1]; let b = img[j + 2]; const\n          a = img[j + 3];\n        if (a == 0) r = g = b = 0;\n        nimg[noff + j] = r; nimg[noff + j + 1] = g; nimg[noff + j + 2] = b; nimg[noff + j + 3] = a;\n      }\n      noff += il;\n    }\n    return nimg.buffer;\n  }\n\n  UPNG.encode = encode;\n  UPNG.encodeLL = encodeLL;\n  UPNG.encode.compress = compress;\n  UPNG.encode.dither = dither;\n\n  UPNG.quantize = quantize;\n  UPNG.quantize.getKDtree = getKDtree;\n  UPNG.quantize.getNearest = getNearest;\n}());\n\nexport default UPNG;\n","// https://github.com/marcosvega91/canvas-to-bmp/blob/77aaf2221647a6533b1926cb637c7cd2bc432d9b/src/canvastobmp.js\n\n/**\n * Static helper object that can convert a CORS-compliant canvas element\n * to a 32-bits BMP file (buffer, Blob and data-URI).\n *\n * @type {{toArrayBuffer: Function, toBlob: Function, toDataURL: Function}}\n * @namespace\n */\nconst CanvasToBMP = {\n\n  /**\n\t * Convert a canvas element to ArrayBuffer containing a BMP file\n\t * with support for 32-bit format (alpha). The call is asynchronous\n\t * so a callback must be provided.\n\t *\n\t * Note that CORS requirement must be fulfilled.\n\t *\n\t * @param {HTMLCanvasElement} canvas - the canvas element to convert\n\t * @param {function} callback - called when conversion is done. Argument is ArrayBuffer\n\t * @static\n\t */\n  toArrayBuffer(canvas, callback) {\n    const w = canvas.width;\n    const h = canvas.height;\n    const w4 = w << 2;\n    const idata = canvas.getContext('2d').getImageData(0, 0, w, h);\n    const data32 = new Uint32Array(idata.data.buffer);\n\n    const stride = ((32 * w + 31) / 32) << 2;\n    const pixelArraySize = stride * h;\n    const fileLength = 122 + pixelArraySize;\n\n    const file = new ArrayBuffer(fileLength);\n    const view = new DataView(file);\n    const blockSize = 1 << 20;\n    let block = blockSize;\n    let y = 0; let x; let v; let a; let pos = 0; let p; let\n      s = 0;\n\n    // Header\n    set16(0x4d42);\t\t\t\t\t\t\t\t\t\t// BM\n    set32(fileLength);\t\t\t\t\t\t\t\t\t// total length\n    seek(4);\t\t\t\t\t\t\t\t\t\t\t// skip unused fields\n    set32(0x7a);\t\t\t\t\t\t\t\t\t\t// offset to pixels\n\n    // DIB header\n    set32(0x6c);\t\t\t\t\t\t\t\t\t\t// header size (108)\n    set32(w);\n    set32(-h >>> 0);\t\t\t\t\t\t\t\t\t// negative = top-to-bottom\n    set16(1);\t\t\t\t\t\t\t\t\t\t\t// 1 plane\n    set16(32);\t\t\t\t\t\t\t\t\t\t\t// 32-bits (RGBA)\n    set32(3);\t\t\t\t\t\t\t\t\t\t\t// no compression (BI_BITFIELDS, 3)\n    set32(pixelArraySize);\t\t\t\t\t\t\t\t// bitmap size incl. padding (stride x height)\n    set32(2835);\t\t\t\t\t\t\t\t\t\t// pixels/meter h (~72 DPI x 39.3701 inch/m)\n    set32(2835);\t\t\t\t\t\t\t\t\t\t// pixels/meter v\n    seek(8);\t\t\t\t\t\t\t\t\t\t\t// skip color/important colors\n    set32(0xff0000);\t\t\t\t\t\t\t\t\t// red channel mask\n    set32(0xff00);\t\t\t\t\t\t\t\t\t\t// green channel mask\n    set32(0xff);\t\t\t\t\t\t\t\t\t\t// blue channel mask\n    set32(0xff000000);\t\t\t\t\t\t\t\t\t// alpha channel mask\n    set32(0x57696e20);\t\t\t\t\t\t\t\t\t// \" win\" color space\n\n    (function convert() {\n      // bitmap data, change order of ABGR to BGRA (msb-order)\n      while (y < h && block > 0) {\n        p = 0x7a + y * stride;\t\t\t\t\t\t// offset + stride x height\n        x = 0;\n\n        while (x < w4) {\n          block--;\n          v = data32[s++];\t\t\t\t\t\t// get ABGR\n          a = v >>> 24;\t\t\t\t\t\t\t// alpha\n          view.setUint32(p + x, (v << 8) | a); // set BGRA (msb order)\n          x += 4;\n        }\n        y++;\n      }\n\n      if (s < data32.length) {\n        block = blockSize;\n        setTimeout(convert, CanvasToBMP._dly);\n      } else callback(file);\n    }());\n\n    // helper method to move current buffer position\n    function set16(data) {\n      view.setUint16(pos, data, true);\n      pos += 2;\n    }\n\n    function set32(data) {\n      view.setUint32(pos, data, true);\n      pos += 4;\n    }\n\n    function seek(delta) { pos += delta; }\n  },\n\n  /**\n\t * Converts a canvas to BMP file, returns a Blob representing the\n\t * file. This can be used with URL.createObjectURL(). The call is\n\t * asynchronous so a callback must be provided.\n\t *\n\t * Note that CORS requirement must be fulfilled.\n\t *\n\t * @param {HTMLCanvasElement} canvas - the canvas element to convert\n\t * @param {function} callback - called when conversion is done. Argument is a Blob\n\t * @static\n\t */\n  toBlob(canvas, callback) {\n    this.toArrayBuffer(canvas, (file) => {\n      callback(new Blob([file], { type: 'image/bmp' }));\n    });\n  },\n\n  // /**\n\t//  * Converts a canvas to BMP file, returns an ObjectURL (for Blob)\n\t//  * representing the file. The call is asynchronous so a callback\n\t//  * must be provided.\n\t//  *\n\t//  * **Important**: To avoid memory-leakage you must revoke the returned\n\t//  * ObjectURL when no longer needed:\n\t//  *\n\t//  *     var _URL = self.URL || self.webkitURL || self;\n\t//  *     _URL.revokeObjectURL(url);\n\t//  *\n\t//  * Note that CORS requirement must be fulfilled.\n\t//  *\n\t//  * @param {HTMLCanvasElement} canvas - the canvas element to convert\n\t//  * @param {function} callback - called when conversion is done. Argument is a Blob\n\t//  * @static\n\t//  */\n  // toObjectURL(canvas, callback) {\n  //   this.toBlob(canvas, (blob) => {\n  //     const url = self.URL || self.webkitURL || self;\n  //     callback(url.createObjectURL(blob));\n  //   });\n  // },\n\n  // /**\n\t//  * Converts the canvas to a data-URI representing a BMP file. The\n\t//  * call is asynchronous so a callback must be provided.\n\t//  *\n\t//  * Note that CORS requirement must be fulfilled.\n\t//  *\n\t//  * @param {HTMLCanvasElement} canvas - the canvas element to convert\n\t//  * @param {function} callback - called when conversion is done. Argument is an data-URI (string)\n\t//  * @static\n\t//  */\n  // toDataURL(canvas, callback) {\n  //   this.toArrayBuffer(canvas, (file) => {\n  //     const buffer = new Uint8Array(file);\n  //     const blockSize = 1 << 20;\n  //     let block = blockSize;\n  //     let bs = ''; let base64 = ''; let i = 0; let\n  //       l = buffer.length;\n\n  //     // This is a necessary step before we can use btoa. We can\n  //     // replace this later with a direct byte-buffer to Base-64 routine.\n  //     // Will do for now, impacts only with very large bitmaps (in which\n  //     // case toBlob should be used).\n  //     (function prepBase64() {\n  //       while (i < l && block-- > 0) bs += String.fromCharCode(buffer[i++]);\n\n  //       if (i < l) {\n  //         block = blockSize;\n  //         setTimeout(prepBase64, CanvasToBMP._dly);\n  //       } else {\n  //         // convert string to Base-64\n  //         i = 0;\n  //         l = bs.length;\n  //         block = 180000;\t\t// must be divisible by 3\n\n  //         (function toBase64() {\n  //           base64 += btoa(bs.substr(i, block));\n  //           i += block;\n  //           (i < l)\n  //             ? setTimeout(toBase64, CanvasToBMP._dly)\n  //             : callback(`data:image/bmp;base64,${base64}`);\n  //         }());\n  //       }\n  //     }());\n  //   });\n  // },\n  _dly: 9,\t// delay for async operations\n};\nexport default CanvasToBMP;\n","export default {\n  CHROME: 'CHROME',\n  FIREFOX: 'FIREFOX',\n  DESKTOP_SAFARI: 'DESKTOP_SAFARI',\n  IE: 'IE',\n  IOS: 'IOS',\n  ETC: 'ETC',\n};\n","import BROWSER_NAME from './browser-name';\n\n// see: https://github.com/jhildenbiddle/canvas-size#test-results\n// see: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nexport default {\n  [BROWSER_NAME.CHROME]: 16384,\n  [BROWSER_NAME.FIREFOX]: 11180,\n  [BROWSER_NAME.DESKTOP_SAFARI]: 16384,\n  [BROWSER_NAME.IE]: 8192,\n  [BROWSER_NAME.IOS]: 4096,\n  [BROWSER_NAME.ETC]: 8192,\n};\n","import UPNG from './UPNG';\nimport CanvasToBMP from './canvastobmp';\nimport MAX_CANVAS_SIZE from './config/max-canvas-size';\nimport BROWSER_NAME from './config/browser-name';\n\nconst isBrowser = typeof window !== 'undefined'; // change browser environment to support SSR\nconst inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n\n// add support for cordova-plugin-file\nconst moduleMapper = isBrowser && window.cordova && window.cordova.require && window.cordova.require('cordova/modulemapper');\nexport const CustomFile = (isBrowser || inWebWorker) && ((moduleMapper && moduleMapper.getOriginalSymbol(window, 'File')) || (typeof File !== 'undefined' && File));\nexport const CustomFileReader = (isBrowser || inWebWorker) && ((moduleMapper && moduleMapper.getOriginalSymbol(window, 'FileReader')) || (typeof FileReader !== 'undefined' && FileReader));\n\n/**\n * getFilefromDataUrl\n *\n * @param {string} dataUrl\n * @param {string} filename\n * @param {number} [lastModified=Date.now()]\n * @returns {Promise<File | Blob>}\n */\nexport function getFilefromDataUrl(dataUrl, filename, lastModified = Date.now()) {\n  return new Promise((resolve) => {\n    const arr = dataUrl.split(',');\n    const mime = arr[0].match(/:(.*?);/)[1];\n    const bstr = globalThis.atob(arr[1]);\n    let n = bstr.length;\n    const u8arr = new Uint8Array(n);\n    while (n--) {\n      u8arr[n] = bstr.charCodeAt(n);\n    }\n    const file = new Blob([u8arr], { type: mime });\n    file.name = filename;\n    file.lastModified = lastModified;\n    resolve(file);\n\n    // Safari has issue with File constructor not being able to POST in FormData\n    // https://github.com/Donaldcwl/browser-image-compression/issues/8\n    // https://bugs.webkit.org/show_bug.cgi?id=165081\n    // let file\n    // try {\n    //   file = new File([u8arr], filename, { type: mime }) // Edge do not support File constructor\n    // } catch (e) {\n    //   file = new Blob([u8arr], { type: mime })\n    //   file.name = filename\n    //   file.lastModified = lastModified\n    // }\n    // resolve(file)\n  });\n}\n\n/**\n * getDataUrlFromFile\n *\n * @param {File | Blob} file\n * @returns {Promise<string>}\n */\nexport function getDataUrlFromFile(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new CustomFileReader();\n    reader.onload = () => resolve(reader.result);\n    reader.onerror = (e) => reject(e);\n    reader.readAsDataURL(file);\n  });\n}\n\n/**\n * loadImage\n *\n * @param {string} src\n * @returns {Promise<HTMLImageElement>}\n */\nexport function loadImage(src) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = (e) => reject(e);\n    img.src = src;\n  });\n}\n\n/**\n * getBrowserName\n *\n * Extracts the browser name from the useragent.\n *\n * ref: https://stackoverflow.com/a/26358856\n *\n * @returns {string}\n */\nexport function getBrowserName() {\n  if (getBrowserName.cachedResult !== undefined) {\n    return getBrowserName.cachedResult;\n  }\n  let browserName = BROWSER_NAME.ETC;\n  const { userAgent } = navigator;\n  if (/Chrom(e|ium)/i.test(userAgent)) {\n    browserName = BROWSER_NAME.CHROME;\n  } else if (/iP(ad|od|hone)/i.test(userAgent) && /WebKit/i.test(userAgent)) {\n    browserName = BROWSER_NAME.IOS;\n  } else if (/Safari/i.test(userAgent)) {\n    browserName = BROWSER_NAME.DESKTOP_SAFARI;\n  } else if (/Firefox/i.test(userAgent)) {\n    browserName = BROWSER_NAME.FIREFOX;\n  } else if (/MSIE/i.test(userAgent) || (!!document.documentMode) === true) { // IF IE > 10\n    browserName = BROWSER_NAME.IE;\n  }\n  getBrowserName.cachedResult = browserName;\n  return getBrowserName.cachedResult;\n}\n\n/**\n * approximateBelowCanvasMaximumSizeOfBrowser\n *\n * it uses binary search to converge below the browser's maximum Canvas size.\n *\n * @param {number} initWidth\n * @param {number} initHeight\n * @returns {object}\n */\nexport function approximateBelowMaximumCanvasSizeOfBrowser(initWidth, initHeight) {\n  const browserName = getBrowserName();\n  const maximumCanvasSize = MAX_CANVAS_SIZE[browserName];\n\n  let width = initWidth;\n  let height = initHeight;\n  let size = width * height;\n  const ratio = width > height ? height / width : width / height;\n\n  while (size > maximumCanvasSize * maximumCanvasSize) {\n    const halfSizeWidth = (maximumCanvasSize + width) / 2;\n    const halfSizeHeight = (maximumCanvasSize + height) / 2;\n    if (halfSizeWidth < halfSizeHeight) {\n      height = halfSizeHeight;\n      width = halfSizeHeight * ratio;\n    } else {\n      height = halfSizeWidth * ratio;\n      width = halfSizeWidth;\n    }\n\n    size = width * height;\n  }\n\n  return {\n    width, height,\n  };\n}\n\n/**\n * get new Canvas and it's context\n * @param width\n * @param height\n * @returns {[HTMLCanvasElement | OffscreenCanvas, CanvasRenderingContext2D]}\n */\nexport function getNewCanvasAndCtx(width, height) {\n  let canvas;\n  let ctx;\n  try {\n    canvas = new OffscreenCanvas(width, height);\n    ctx = canvas.getContext('2d');\n    if (ctx === null) {\n      throw new Error('getContext of OffscreenCanvas returns null');\n    }\n  } catch (e) {\n    canvas = document.createElement('canvas');\n    ctx = canvas.getContext('2d');\n  }\n  canvas.width = width;\n  canvas.height = height;\n  // ctx.fillStyle = '#fff'\n  // ctx.fillRect(0, 0, width, height)\n  return [canvas, ctx];\n}\n\n/**\n * drawImageInCanvas\n *\n * @param {HTMLImageElement} img\n * @param {string} [fileType=undefined]\n * @returns {HTMLCanvasElement | OffscreenCanvas}\n */\nexport function drawImageInCanvas(img, fileType = undefined) {\n  const { width, height } = approximateBelowMaximumCanvasSizeOfBrowser(img.width, img.height);\n  const [canvas, ctx] = getNewCanvasAndCtx(width, height);\n  if (fileType && /jpe?g/.test(fileType)) {\n    ctx.fillStyle = 'white'; // to fill the transparent background with white color for png file in jpeg extension\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n  }\n  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n  return canvas;\n}\n\n/**\n * Detect IOS device\n * see: https://stackoverflow.com/a/9039885\n * @returns {boolean} isIOS device\n */\nexport function isIOS() {\n  if (isIOS.cachedResult !== undefined) {\n    return isIOS.cachedResult;\n  }\n  isIOS.cachedResult = [\n    'iPad Simulator',\n    'iPhone Simulator',\n    'iPod Simulator',\n    'iPad',\n    'iPhone',\n    'iPod',\n  ].includes(navigator.platform)\n  // iPad on iOS 13 detection\n  || (navigator.userAgent.includes('Mac') && typeof document !== 'undefined' && 'ontouchend' in document);\n  return isIOS.cachedResult;\n}\n\n/**\n * drawFileInCanvas\n *\n * @param {File | Blob} file\n * @returns {Promise<[ImageBitmap | HTMLImageElement, HTMLCanvasElement | OffscreenCanvas]>}\n */\nexport async function drawFileInCanvas(file, options = {}) {\n  let img;\n  try {\n    if (isIOS() || [BROWSER_NAME.DESKTOP_SAFARI, BROWSER_NAME.MOBILE_SAFARI].includes(getBrowserName())) {\n      throw new Error('Skip createImageBitmap on IOS and Safari'); // see https://github.com/Donaldcwl/browser-image-compression/issues/118\n    }\n    img = await createImageBitmap(file);\n  } catch (e) {\n    if (process.env.BUILD === 'development') {\n      console.error(e);\n    }\n    try {\n      const dataUrl = await getDataUrlFromFile(file);\n      img = await loadImage(dataUrl);\n    } catch (e2) {\n      if (process.env.BUILD === 'development') {\n        console.error(e2);\n      }\n      throw e2;\n    }\n  }\n  const canvas = drawImageInCanvas(img, options.fileType || file.type);\n  return [img, canvas];\n}\n\n/**\n * canvasToFile\n *\n * @param {HTMLCanvasElement | OffscreenCanvas} canvas\n * @param {string} fileType\n * @param {string} fileName\n * @param {number} fileLastModified\n * @param {number} [quality]\n * @returns {Promise<File | Blob>}\n */\nexport async function canvasToFile(canvas, fileType, fileName, fileLastModified, quality = 1) {\n  let file;\n  if (fileType === 'image/png') {\n    const ctx = canvas.getContext('2d');\n    const { data } = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    if (process.env.BUILD === 'development') {\n      console.log('png no. of colors', 4096 * quality);\n    }\n    const png = UPNG.encode([data.buffer], canvas.width, canvas.height, 4096 * quality);\n    file = new Blob([png], { type: fileType });\n    file.name = fileName;\n    file.lastModified = fileLastModified;\n  } else if (fileType === 'image/bmp') {\n    file = await new Promise((resolve) => CanvasToBMP.toBlob(canvas, resolve));\n    file.name = fileName;\n    file.lastModified = fileLastModified;\n  } else if (typeof OffscreenCanvas === 'function' && canvas instanceof OffscreenCanvas) { // checked on Win Chrome 83, MacOS Chrome 83\n    file = await canvas.convertToBlob({ type: fileType, quality });\n    file.name = fileName;\n    file.lastModified = fileLastModified;\n  // some browser do not support quality parameter, see: https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob\n  // } else if (typeof canvas.toBlob === 'function') {\n  //   file = await new Promise(resolve => canvas.toBlob(resolve, fileType, quality))\n  } else { // checked on Win Edge 44, Win IE 11, Win Firefox 76, MacOS Firefox 77, MacOS Safari 13.1\n    const dataUrl = canvas.toDataURL(fileType, quality);\n    file = await getFilefromDataUrl(dataUrl, fileName, fileLastModified);\n  }\n  return file;\n}\n\n/**\n * clear Canvas memory\n * @param canvas\n * @returns null\n */\nexport function cleanupCanvasMemory(canvas) {\n  // garbage clean canvas for safari\n  // ref: https://bugs.webkit.org/show_bug.cgi?id=195325\n  // eslint-disable-next-line no-param-reassign\n  canvas.width = 0;\n  // eslint-disable-next-line no-param-reassign\n  canvas.height = 0;\n}\n\n// Check if browser supports automatic image orientation\n// see https://github.com/blueimp/JavaScript-Load-Image/blob/1e4df707821a0afcc11ea0720ee403b8759f3881/js/load-image-orientation.js#L37-L53\nexport async function isAutoOrientationInBrowser() {\n  if (isAutoOrientationInBrowser.cachedResult !== undefined) return isAutoOrientationInBrowser.cachedResult;\n\n  // black 2x1 JPEG, with the following meta information set:\n  // EXIF Orientation: 6 (Rotated 90° CCW)\n  const testImageURL = 'data:image/jpeg;base64,/9j/4QAiRXhpZgAATU0AKgAAAAgAAQESAAMAAAABAAYAAAA'\n    + 'AAAD/2wCEAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBA'\n    + 'QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQE'\n    + 'BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAf/AABEIAAEAAgMBEQACEQEDEQH/x'\n    + 'ABKAAEAAAAAAAAAAAAAAAAAAAALEAEAAAAAAAAAAAAAAAAAAAAAAQEAAAAAAAAAAAAAAAA'\n    + 'AAAAAEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8H//2Q==';\n  const testImageFile = await getFilefromDataUrl(testImageURL, 'test.jpg', Date.now());\n\n  const testImageCanvas = (await drawFileInCanvas(testImageFile))[1];\n  const testImageFile2 = await canvasToFile(testImageCanvas, testImageFile.type, testImageFile.name, testImageFile.lastModified);\n  cleanupCanvasMemory(testImageCanvas);\n  const img = (await drawFileInCanvas(testImageFile2))[0];\n  // console.log('img', img.width, img.height)\n\n  isAutoOrientationInBrowser.cachedResult = img.width === 1 && img.height === 2;\n  return isAutoOrientationInBrowser.cachedResult;\n}\n\n/**\n * getExifOrientation\n * get image exif orientation info\n * source: https://stackoverflow.com/a/32490603/10395024\n *\n * @param {File | Blob} file\n * @returns {Promise<number>} - orientation id, see https://i.stack.imgur.com/VGsAj.gif\n */\nexport function getExifOrientation(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new CustomFileReader();\n    reader.onload = (e) => {\n      const view = new DataView(e.target.result);\n      if (view.getUint16(0, false) != 0xFFD8) {\n        return resolve(-2); // not jpeg\n      }\n      const length = view.byteLength;\n      let offset = 2;\n      while (offset < length) {\n        if (view.getUint16(offset + 2, false) <= 8) return resolve(-1);\n        const marker = view.getUint16(offset, false);\n        offset += 2;\n        if (marker == 0xFFE1) {\n          if (view.getUint32(offset += 2, false) != 0x45786966) {\n            return resolve(-1);\n          }\n\n          const little = view.getUint16(offset += 6, false) == 0x4949;\n          offset += view.getUint32(offset + 4, little);\n          const tags = view.getUint16(offset, little);\n          offset += 2;\n          for (let i = 0; i < tags; i++) {\n            if (view.getUint16(offset + (i * 12), little) == 0x0112) {\n              return resolve(view.getUint16(offset + (i * 12) + 8, little));\n            }\n          }\n        } else if ((marker & 0xFF00) != 0xFF00) {\n          break;\n        } else {\n          offset += view.getUint16(offset, false);\n        }\n      }\n      return resolve(-1); // not defined\n    };\n    reader.onerror = (e) => reject(e);\n    reader.readAsArrayBuffer(file);\n  });\n}\n\n/**\n *\n * @param {HTMLCanvasElement | OffscreenCanvas} canvas\n * @param options\n * @returns {HTMLCanvasElement | OffscreenCanvas}\n */\nexport function handleMaxWidthOrHeight(canvas, options) {\n  const { width } = canvas;\n  const { height } = canvas;\n  const { maxWidthOrHeight } = options;\n\n  const needToHandle = isFinite(maxWidthOrHeight) && (width > maxWidthOrHeight || height > maxWidthOrHeight);\n\n  let newCanvas = canvas;\n  let ctx;\n\n  if (needToHandle) {\n    [newCanvas, ctx] = getNewCanvasAndCtx(width, height);\n    if (width > height) {\n      newCanvas.width = maxWidthOrHeight;\n      newCanvas.height = (height / width) * maxWidthOrHeight;\n    } else {\n      newCanvas.width = (width / height) * maxWidthOrHeight;\n      newCanvas.height = maxWidthOrHeight;\n    }\n    ctx.drawImage(canvas, 0, 0, newCanvas.width, newCanvas.height);\n\n    cleanupCanvasMemory(canvas);\n  }\n\n  return newCanvas;\n}\n\n/**\n * followExifOrientation\n * source: https://stackoverflow.com/a/40867559/10395024\n *\n * @param {HTMLCanvasElement | OffscreenCanvas} canvas\n * @param {number} exifOrientation\n * @returns {HTMLCanvasElement | OffscreenCanvas} canvas\n */\nexport function followExifOrientation(canvas, exifOrientation) {\n  const { width } = canvas;\n  const { height } = canvas;\n\n  const [newCanvas, ctx] = getNewCanvasAndCtx(width, height);\n\n  // set proper canvas dimensions before transform & export\n  if (exifOrientation > 4 && exifOrientation < 9) {\n    newCanvas.width = height;\n    newCanvas.height = width;\n  } else {\n    newCanvas.width = width;\n    newCanvas.height = height;\n  }\n\n  // transform context before drawing image\n  switch (exifOrientation) {\n    case 2:\n      ctx.transform(-1, 0, 0, 1, width, 0);\n      break;\n    case 3:\n      ctx.transform(-1, 0, 0, -1, width, height);\n      break;\n    case 4:\n      ctx.transform(1, 0, 0, -1, 0, height);\n      break;\n    case 5:\n      ctx.transform(0, 1, 1, 0, 0, 0);\n      break;\n    case 6:\n      ctx.transform(0, 1, -1, 0, height, 0);\n      break;\n    case 7:\n      ctx.transform(0, -1, -1, 0, height, width);\n      break;\n    case 8:\n      ctx.transform(0, -1, 1, 0, 0, width);\n      break;\n    default:\n      break;\n  }\n\n  ctx.drawImage(canvas, 0, 0, width, height);\n\n  cleanupCanvasMemory(canvas);\n\n  return newCanvas;\n}\n","import {\n  canvasToFile,\n  cleanupCanvasMemory,\n  drawFileInCanvas,\n  followExifOrientation,\n  getExifOrientation,\n  getNewCanvasAndCtx,\n  handleMaxWidthOrHeight,\n  isAutoOrientationInBrowser,\n} from './utils';\n\n/**\n * Compress an image file.\n *\n * @param {File} file\n * @param {Object} options\n * @param {number} [options.maxSizeMB=Number.POSITIVE_INFINITY]\n * @param {number} [options.maxWidthOrHeight=undefined]\n * @param {boolean} [options.useWebWorker=true]\n * @param {number} [options.maxIteration=10]\n * @param {number} [options.exifOrientation] - default to be the exif orientation from the image file\n * @param {Function} [options.onProgress] - a function takes one progress argument (progress from 0 to 100)\n * @param {string} [options.fileType] - default to be the original mime type from the image file\n * @param {number} [options.initialQuality=1.0]\n * @param {boolean} [options.alwaysKeepResolution=false]\n * @param {AbortSignal} [options.signal]\n * @param {number} previousProgress - for internal try catch rerunning start from previous progress\n * @returns {Promise<File | Blob>}\n */\nexport default async function compress(file, options, previousProgress = 0) {\n  let progress = previousProgress;\n\n  function incProgress(inc = 5) {\n    if (options.signal && options.signal.aborted) {\n      throw options.signal.reason;\n    }\n    progress += inc;\n    options.onProgress(Math.min(progress, 100));\n  }\n\n  function setProgress(p) {\n    if (options.signal && options.signal.aborted) {\n      throw options.signal.reason;\n    }\n    progress = Math.min(Math.max(p, progress), 100);\n    options.onProgress(progress);\n  }\n\n  let remainingTrials = options.maxIteration || 10;\n\n  const maxSizeByte = options.maxSizeMB * 1024 * 1024;\n\n  incProgress();\n\n  // drawFileInCanvas\n  const [, origCanvas] = await drawFileInCanvas(file, options);\n\n  incProgress();\n\n  // handleMaxWidthOrHeight\n  const maxWidthOrHeightFixedCanvas = handleMaxWidthOrHeight(origCanvas, options);\n\n  incProgress();\n\n  // exifOrientation\n  const exifOrientation = options.exifOrientation || await getExifOrientation(file);\n  incProgress();\n  const orientationFixedCanvas = (await isAutoOrientationInBrowser()) ? maxWidthOrHeightFixedCanvas : followExifOrientation(maxWidthOrHeightFixedCanvas, exifOrientation);\n  incProgress();\n\n  let quality = options.initialQuality || 1.0;\n\n  const outputFileType = options.fileType || file.type;\n\n  const tempFile = await canvasToFile(orientationFixedCanvas, outputFileType, file.name, file.lastModified, quality);\n  incProgress();\n\n  const origExceedMaxSize = tempFile.size > maxSizeByte;\n  const sizeBecomeLarger = tempFile.size > file.size;\n  if (process.env.BUILD === 'development') {\n    console.log('outputFileType', outputFileType);\n    console.log('original file size', file.size);\n    console.log('current file size', tempFile.size);\n  }\n\n  // check if we need to compress or resize\n  if (!origExceedMaxSize && !sizeBecomeLarger) {\n    // no need to compress\n    if (process.env.BUILD === 'development') {\n      console.log('no need to compress');\n    }\n    setProgress(100);\n    return tempFile;\n  }\n\n  const sourceSize = file.size;\n  const renderedSize = tempFile.size;\n  let currentSize = renderedSize;\n  let compressedFile;\n  let newCanvas;\n  let ctx;\n  let canvas = orientationFixedCanvas;\n  const shouldReduceResolution = !options.alwaysKeepResolution && origExceedMaxSize;\n  while (remainingTrials-- && (currentSize > maxSizeByte || currentSize > sourceSize)) {\n    const newWidth = shouldReduceResolution ? canvas.width * 0.95 : canvas.width;\n    const newHeight = shouldReduceResolution ? canvas.height * 0.95 : canvas.height;\n    if (process.env.BUILD === 'development') {\n      console.log('current width', newWidth);\n      console.log('current height', newHeight);\n      console.log('current quality', quality);\n    }\n    [newCanvas, ctx] = getNewCanvasAndCtx(newWidth, newHeight);\n\n    ctx.drawImage(canvas, 0, 0, newWidth, newHeight);\n\n    if (outputFileType === 'image/png') {\n      quality *= 0.85;\n    } else {\n      quality *= 0.95;\n    }\n    // eslint-disable-next-line no-await-in-loop\n    compressedFile = await canvasToFile(newCanvas, outputFileType, file.name, file.lastModified, quality);\n\n    cleanupCanvasMemory(canvas);\n\n    canvas = newCanvas;\n\n    currentSize = compressedFile.size;\n    // console.log('currentSize', currentSize)\n    setProgress(Math.min(99, Math.floor(((renderedSize - currentSize) / (renderedSize - maxSizeByte)) * 100)));\n  }\n\n  cleanupCanvasMemory(canvas);\n  cleanupCanvasMemory(newCanvas);\n  cleanupCanvasMemory(maxWidthOrHeightFixedCanvas);\n  cleanupCanvasMemory(orientationFixedCanvas);\n  cleanupCanvasMemory(origCanvas);\n\n  setProgress(100);\n  return compressedFile;\n}\n","function createWorkerScriptURL(script) {\n  const blobArgs = [];\n  if (typeof script === 'function') {\n    blobArgs.push(`(${script})()`);\n  } else {\n    blobArgs.push(script);\n  }\n  return URL.createObjectURL(new Blob(blobArgs));\n}\n\nconst workerScript = `\nlet scriptImported = false\nself.addEventListener('message', async (e) => {\n  const { file, id, imageCompressionLibUrl, options } = e.data\n  options.onProgress = (progress) => self.postMessage({ progress, id })\n  try {\n    if (!scriptImported) {\n      // console.log('[worker] importScripts', imageCompressionLibUrl)\n      self.importScripts(imageCompressionLibUrl)\n      scriptImported = true\n    }\n    // console.log('[worker] self', self)\n    const compressedFile = await imageCompression(file, options)\n    self.postMessage({ file: compressedFile, id })\n  } catch (e) {\n    // console.error('[worker] error', e)\n    self.postMessage({ error: e.message + '\\\\n' + e.stack, id })\n  }\n})\n`;\nlet workerScriptURL;\n\nexport default function compressOnWebWorker(file, options) {\n  return new Promise((resolve, reject) => {\n    if (!workerScriptURL) {\n      workerScriptURL = createWorkerScriptURL(workerScript);\n    }\n    const worker = new Worker(workerScriptURL);\n\n    function handler(e) {\n      if (options.signal && options.signal.aborted) {\n        worker.terminate();\n        return;\n      }\n      if (e.data.progress !== undefined) {\n        options.onProgress(e.data.progress);\n        return;\n      }\n      if (e.data.error) {\n        reject(new Error(e.data.error));\n        worker.terminate();\n        return;\n      }\n      resolve(e.data.file);\n      worker.terminate();\n    }\n\n    worker.addEventListener('message', handler);\n    worker.addEventListener('error', reject);\n    if (options.signal) {\n      options.signal.addEventListener('abort', () => {\n        reject(options.signal.reason);\n        worker.terminate();\n      });\n    }\n\n    worker.postMessage({\n      file,\n      imageCompressionLibUrl: options.libURL,\n      options: { ...options, onProgress: undefined, signal: undefined },\n    });\n  });\n}\n","import copyExifWithoutOrientation from './copyExifWithoutOrientation';\nimport compress from './image-compression';\nimport {\n  canvasToFile,\n  drawFileInCanvas,\n  drawImageInCanvas,\n  getDataUrlFromFile,\n  getFilefromDataUrl,\n  loadImage,\n  getExifOrientation,\n  handleMaxWidthOrHeight,\n  followExifOrientation,\n  CustomFile,\n  cleanupCanvasMemory,\n  isAutoOrientationInBrowser,\n  approximateBelowMaximumCanvasSizeOfBrowser,\n  getBrowserName,\n} from './utils';\nimport compressOnWebWorker from './web-worker';\n\n/**\n * Compress an image file.\n *\n * @param {File} file\n * @param {Object} options\n * @param {number} [options.maxSizeMB=Number.POSITIVE_INFINITY]\n * @param {number} [options.maxWidthOrHeight=undefined]\n * @param {boolean} [options.useWebWorker=true]\n * @param {number} [options.maxIteration=10]\n * @param {number} [options.exifOrientation] - default to be the exif orientation from the image file\n * @param {Function} [options.onProgress] - a function takes one progress argument (progress from 0 to 100)\n * @param {string} [options.fileType] - default to be the original mime type from the image file\n * @param {number} [options.initialQuality=1.0]\n * @param {boolean} [options.alwaysKeepResolution=false]\n * @param {AbortSignal} [options.signal]\n * @param {boolean} [options.preserveExif] - preserve Exif metadata\n * @param {string} [options.libURL] - URL to this library\n * @returns {Promise<File | Blob>}\n */\nasync function imageCompression(file, options) {\n  const opts = { ...options };\n\n  let compressedFile;\n  let progress = 0;\n  const { onProgress } = opts;\n\n  opts.maxSizeMB = opts.maxSizeMB || Number.POSITIVE_INFINITY;\n  const useWebWorker = typeof opts.useWebWorker === 'boolean' ? opts.useWebWorker : true;\n  delete opts.useWebWorker;\n  opts.onProgress = (aProgress) => {\n    progress = aProgress;\n    if (typeof onProgress === 'function') {\n      onProgress(progress);\n    }\n  };\n\n  if (!(file instanceof Blob || file instanceof CustomFile)) {\n    throw new Error('The file given is not an instance of Blob or File');\n  } else if (!/^image/.test(file.type)) {\n    throw new Error('The file given is not an image');\n  }\n\n  // try run in web worker, fall back to run in main thread\n  // eslint-disable-next-line no-undef, no-restricted-globals\n  const inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n\n  if (process.env.BUILD === 'development') {\n    if ((useWebWorker && typeof Worker === 'function') || inWebWorker) {\n      console.log('run compression in web worker');\n    } else {\n      console.log('run compression in main thread');\n    }\n  }\n\n  if (useWebWorker && typeof Worker === 'function' && !inWebWorker) {\n    try {\n      // \"compressOnWebWorker\" is kind of like a recursion to call \"imageCompression\" again inside web worker\n      opts.libURL = opts.libURL || `https://cdn.jsdelivr.net/npm/browser-image-compression@${__buildVersion__}/dist/browser-image-compression.js`;\n      compressedFile = await compressOnWebWorker(file, opts);\n    } catch (e) {\n      if (process.env.BUILD === 'development') {\n        console.warn('Run compression in web worker failed:', e, ', fall back to main thread');\n      }\n      compressedFile = await compress(file, opts);\n    }\n  } else {\n    compressedFile = await compress(file, opts);\n  }\n\n  try {\n    compressedFile.name = file.name;\n    compressedFile.lastModified = file.lastModified;\n  } catch (e) {\n    if (process.env.BUILD === 'development') {\n      console.error(e);\n    }\n  }\n\n  try {\n    if (opts.preserveExif && file.type === 'image/jpeg' && (!opts.fileType || (opts.fileType && opts.fileType === file.type))) {\n      if (process.env.BUILD === 'development') {\n        console.log('copyExifWithoutOrientation');\n      }\n      compressedFile = copyExifWithoutOrientation(file, compressedFile);\n    }\n  } catch (e) {\n    if (process.env.BUILD === 'development') {\n      console.error(e);\n    }\n  }\n\n  return compressedFile;\n}\n\nimageCompression.getDataUrlFromFile = getDataUrlFromFile;\nimageCompression.getFilefromDataUrl = getFilefromDataUrl;\nimageCompression.loadImage = loadImage;\nimageCompression.drawImageInCanvas = drawImageInCanvas;\nimageCompression.drawFileInCanvas = drawFileInCanvas;\nimageCompression.canvasToFile = canvasToFile;\nimageCompression.getExifOrientation = getExifOrientation;\n\nimageCompression.handleMaxWidthOrHeight = handleMaxWidthOrHeight;\nimageCompression.followExifOrientation = followExifOrientation;\nimageCompression.cleanupCanvasMemory = cleanupCanvasMemory;\nimageCompression.isAutoOrientationInBrowser = isAutoOrientationInBrowser;\nimageCompression.approximateBelowMaximumCanvasSizeOfBrowser = approximateBelowMaximumCanvasSizeOfBrowser;\nimageCompression.copyExifWithoutOrientation = copyExifWithoutOrientation;\nimageCompression.getBrowserName = getBrowserName;\nimageCompression.version = __buildVersion__;\n\nexport default imageCompression;\n"]},"metadata":{},"sourceType":"module"}